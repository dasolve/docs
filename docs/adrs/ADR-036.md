# ADR-036: Rate Limiting for Backend APIs

## Context

Backend APIs require protection from malicious actors attempting to abuse or overwhelm the system. Without rate limiting, applications face several critical security and operational risks:

- **Denial of Service (DDoS):** Attackers can overwhelm APIs with excessive requests, making services unavailable to legitimate users
- **Service Degradation:** High volumes of malicious requests consume server resources (CPU, memory, database connections), degrading performance
- **Brute Force Attacks:** Attackers can attempt to guess credentials or API keys through rapid successive requests
- **Data Scraping:** Malicious actors can extract large amounts of data through automated requests
- **Resource Exhaustion:** Uncontrolled API access can exhaust system resources, causing failures

For **enterprise applications** built on the Dasolve framework deployed in single-tenant environments:

- **Security First:** Protection against targeted attacks and malicious usage patterns
- **Service Stability:** Systems must remain responsive under potential attack scenarios
- **Compliance Requirements:** Some security policies require protection against automated abuse
- **Backend for Frontend:** BFF architecture ([ADR-030](./ADR-030.md)) serves dedicated frontends, but still needs protection from bugs or malicious clients
- **Authenticated Access:** Even with Azure AD authentication ([ADR-035](./ADR-035.md)), compromised accounts or malicious authenticated users can abuse APIs

**Rate limiting strategies** must consider:

1. **Identification:** How to identify users (IP address, user ID from authenticated tokens)
2. **Granularity:** Different limits for different endpoints based on their cost
3. **Storage:** In-memory storage for simplicity (Dasolve backends typically don't scale to multiple replicas)
4. **Response:** How to communicate rate limit status to clients
5. **Bypass:** How to allow certain requests (health checks, internal services) to bypass limits

Without standardized rate limiting, each backend would implement different approaches, leading to:

- Inconsistent security posture across services
- Difficulty in responding to attack patterns
- Poor developer experience with unclear error messages
- Vulnerable endpoints that could be exploited

## Decision

All **backends built on the Dasolve framework** must implement **rate limiting** to protect APIs from malicious abuse and prevent service degradation.

Rate limiting will be implemented with:

- **Middleware-based approach** using `hono-rate-limiter` for consistent application across routes
- **In-memory storage** for simplicity, as backends typically run as single instances without horizontal scaling
- **User-based identification** using authenticated user IDs when available, falling back to IP addresses for public endpoints
- **Standard HTTP headers** (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, Retry-After) to communicate limits to clients
- **Graceful error responses** with clear messages when limits are exceeded
- **Configurable limits** via environment variables for different environments
- **Endpoint-specific limits** allowing stricter limits on expensive or security-sensitive operations

This decision ensures:

- **Security:** APIs are protected from DDoS attacks, brute force attempts, and malicious usage
- **Service Stability:** Systems remain responsive under potential attack scenarios
- **Simplicity:** In-memory implementation avoids additional infrastructure dependencies
- **Transparency:** Clients receive clear feedback about rate limit status
- **Flexibility:** Different limits can be applied based on endpoint sensitivity and cost
- **Consistency:** Standard rate limiting implementation across all Dasolve backends

## Do's and Don'ts

### Do

- **DO** implement rate limiting on all public-facing API endpoints.
- **DO** use authenticated user IDs (from JWT tokens) for rate limiting when authentication is required.
- **DO** fall back to IP-based rate limiting for public/unauthenticated endpoints.
- **DO** use in-memory storage for rate limiting (simple and sufficient for single-instance deployments).
- **DO** return standard HTTP 429 (Too Many Requests) status code when limits are exceeded.
- **DO** include rate limit headers in responses (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset).
- **DO** provide a Retry-After header indicating when the client can retry.
- **DO** apply stricter rate limits to security-sensitive endpoints (authentication, password reset).
- **DO** apply stricter rate limits to expensive operations (complex queries, file uploads, mutations).
- **DO** apply more lenient limits to read-only operations.
- **DO** log rate limit violations for security monitoring and analysis.
- **DO** use environment variables to configure rate limits for different environments.
- **DO** test rate limiting behavior in integration tests.
- **DO** document rate limits in API documentation (OpenAPI specs).
- **DO** monitor rate limit metrics to adjust limits based on actual usage patterns.
- **DO** allow internal service-to-service calls to bypass rate limits.

### Don't

- **DON'T** skip rate limiting on any endpoint accessible from external clients.
- **DON'T** use only IP-based rate limiting for authenticated APIs (compromised accounts could bypass IP-based limits).
- **DON'T** set rate limits so low that legitimate usage is affected.
- **DON'T** return generic error messages when rate limits are exceeded—provide clear guidance.
- **DON'T** forget to include rate limit headers in responses.
- **DON'T** apply the same rate limits to all endpoints regardless of cost.
- **DON'T** hardcode rate limit values in application code.
- **DON'T** silently drop requests when rate limited—always return proper HTTP responses.
- **DON'T** allow unlimited burst sizes without considering impact.
- **DON'T** rate limit health check endpoints or monitoring endpoints.
- **DON'T** forget to document rate limits in API specifications.
- **DON'T** implement rate limiting without monitoring to understand usage patterns.

## Consequences

### Positive

- **Security Protection:** APIs are protected from DDoS attacks, brute force attempts, and data scraping
- **Service Stability:** Ensures consistent performance by preventing resource exhaustion from malicious traffic
- **Attack Mitigation:** Reduces effectiveness of automated attacks and abuse attempts
- **Simplicity:** In-memory implementation requires no additional infrastructure (Redis, etc.)
- **Transparency:** Clients receive clear feedback about their usage and limits
- **Flexibility:** Different limits can be applied based on endpoint sensitivity
- **Monitoring:** Rate limit violations provide insights into potential attacks

### Negative

- **Legitimate Users Affected:** Users with legitimate high usage may occasionally hit limits
- **Configuration Overhead:** Requires tuning limits for different endpoints
- **Initial Calibration:** Determining appropriate limits requires analysis and iteration
- **Proxy Challenges:** Users behind shared corporate proxies may share IP-based limits for unauthenticated endpoints

### Risks

- **False Positives:** Legitimate high-volume usage might be rate limited. Mitigated by:
  - Setting reasonable limits based on expected usage patterns
  - Monitoring rate limit violations to identify legitimate cases
  - Using authenticated user IDs rather than just IP addresses when possible
  - Adjusting limits based on observed legitimate usage
- **Memory Loss on Restart:** In-memory counters reset when the application restarts. Mitigated by:
  - Accepting this as reasonable trade-off for simplicity
  - Short-lived attacks won't benefit from restart resets
  - Rate limit windows are typically short (1-5 minutes)
- **Bypass Vulnerabilities:** Attackers might try to bypass rate limiting. Mitigated by:
  - Applying rate limits at multiple levels (IP and user ID)
  - Implementing additional security layers (authentication, WAF)
  - Regular security audits of rate limiting implementation
  - Logging and monitoring bypass attempts and attack patterns

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve backend scaffolding will include:
  - `hono-rate-limiter` pre-configured with sensible defaults using in-memory storage
  - Environment variables for rate limit configuration
  - Example implementations for different endpoints
  - Integration with authentication middleware
- **Code Reviews:** Reviewers must ensure:
  - All public endpoints have appropriate rate limiting
  - Rate limits are configured via environment variables
  - Proper error responses with rate limit headers
  - Different limits for different endpoint types
  - Authenticated endpoints use user ID for rate limiting
  - Rate limiting is tested in integration tests
- **Documentation Standards:**
  - Rate limits must be documented in OpenAPI specifications
  - API documentation must include rate limit behavior
  - Client libraries should handle 429 responses appropriately

### Standard Implementation

**Basic Rate Limiting Setup** (`packages/backend/src/index.ts`):

```typescript
import { Hono } from "hono";
import { rateLimiter } from "hono-rate-limiter";

const app = new Hono();

// Default rate limiter - 100 requests per minute per user/IP
// Uses in-memory storage (default for hono-rate-limiter)
const defaultRateLimiter = rateLimiter({
  windowMs: 60 * 1000, // 1 minute
  limit: 100,
  standardHeaders: "draft-7", // Include X-RateLimit-* headers
  keyGenerator: (c) => {
    // Use authenticated user ID if available, otherwise IP
    const payload = c.get("jwtPayload");
    if (payload?.sub) {
      return `user:${payload.sub}`;
    }
    return `ip:${
      c.req.header("x-forwarded-for") || c.req.header("x-real-ip") || "unknown"
    }`;
  },
  handler: (c) => {
    return c.json(
      {
        error: "Too many requests",
        message: "Rate limit exceeded. Please try again later.",
      },
      429
    );
  },
});

// Apply default rate limiter to all routes
app.use("*", defaultRateLimiter);

export default app;
```

**Environment-Based Configuration:**

```typescript
// config/rate-limits.ts
interface RateLimitConfig {
  windowMs: number;
  limit: number;
}

interface RateLimits {
  default: RateLimitConfig;
  auth: RateLimitConfig;
  expensive: RateLimitConfig;
  readonly: RateLimitConfig;
}

export const rateLimits: RateLimits = {
  // Default for most endpoints
  default: {
    windowMs: 60 * 1000, // 1 minute
    limit: Number(process.env.RATE_LIMIT_DEFAULT) || 100,
  },
  // Authentication endpoints (stricter to prevent brute force)
  auth: {
    windowMs: 60 * 1000, // 1 minute
    limit: Number(process.env.RATE_LIMIT_AUTH) || 5,
  },
  // Expensive operations (queries, reports, exports)
  expensive: {
    windowMs: 60 * 1000, // 1 minute
    limit: Number(process.env.RATE_LIMIT_EXPENSIVE) || 10,
  },
  // Read-only operations (more lenient)
  readonly: {
    windowMs: 60 * 1000, // 1 minute
    limit: Number(process.env.RATE_LIMIT_READONLY) || 200,
  },
};
```

**User-Based Rate Limiting:**

```typescript
import { rateLimiter } from "hono-rate-limiter";
import { Context } from "hono";

// User-based rate limiter - different limits based on user roles
function createUserRateLimiter(baseLimit: number = 100) {
  return rateLimiter({
    windowMs: 60 * 1000, // 1 minute
    limit: async (c: Context) => {
      const payload = c.get("jwtPayload");
      const roles = payload?.roles || [];

      // Admins get higher limits
      if (roles.includes("Admin")) {
        return baseLimit * 2;
      }

      return baseLimit;
    },
    standardHeaders: "draft-7",
    keyGenerator: (c) => {
      const payload = c.get("jwtPayload");
      return `user:${payload?.sub || "anonymous"}`;
    },
  });
}

// Apply user-based rate limiting to specific routes
app.get("/api/data", authMiddleware, createUserRateLimiter(100), async (c) => {
  const data = await fetchData();
  return c.json(data);
});
```

**Endpoint-Specific Rate Limiting:**

```typescript
import { rateLimiter } from "hono-rate-limiter";
import { rateLimits } from "./config/rate-limits";

// Strict rate limiting for authentication endpoints
const authRateLimiter = rateLimiter({
  ...rateLimits.auth,
  standardHeaders: "draft-7",
  keyGenerator: (c) => {
    // Use IP for auth endpoints (before user is authenticated)
    const ip =
      c.req.header("x-forwarded-for") || c.req.header("x-real-ip") || "unknown";
    return `auth:${ip}`;
  },
  handler: (c) => {
    return c.json(
      {
        error: "Too many authentication attempts",
        message:
          "You have exceeded the maximum number of authentication attempts. Please try again later.",
      },
      429
    );
  },
});

// Strict rate limiting for expensive operations
const expensiveRateLimiter = rateLimiter({
  ...rateLimits.expensive,
  standardHeaders: "draft-7",
  keyGenerator: (c) => {
    const payload = c.get("jwtPayload");
    return `expensive:${payload?.sub || "anonymous"}`;
  },
});

// Lenient rate limiting for read-only operations
const readonlyRateLimiter = rateLimiter({
  ...rateLimits.readonly,
  standardHeaders: "draft-7",
  keyGenerator: (c) => {
    const payload = c.get("jwtPayload");
    return `readonly:${payload?.sub || "anonymous"}`;
  },
});

// Apply to specific routes
app.post("/api/auth/login", authRateLimiter, async (c) => {
  // Handle login
});

app.post(
  "/api/reports/generate",
  authMiddleware,
  expensiveRateLimiter,
  async (c) => {
    // Generate expensive report
  }
);

app.get("/api/products", readonlyRateLimiter, async (c) => {
  // List products (read-only, more lenient)
});
```

**Custom Rate Limit Handler with Retry-After:**

```typescript
import { rateLimiter } from "hono-rate-limiter";

const customRateLimiter = rateLimiter({
  windowMs: 60 * 1000,
  limit: 100,
  standardHeaders: "draft-7",
  keyGenerator: (c) => {
    const payload = c.get("jwtPayload");
    return `user:${payload?.sub || "anonymous"}`;
  },
  handler: (c, _next, options) => {
    const resetTime = options.resetTime || new Date(Date.now() + 60000);
    const retryAfter = Math.ceil((resetTime.getTime() - Date.now()) / 1000);

    return c.json(
      {
        error: "Rate limit exceeded",
        message: `You have exceeded the rate limit. Please try again in ${retryAfter} seconds.`,
        retryAfter,
        limit: options.max,
        remaining: 0,
        reset: resetTime.toISOString(),
      },
      429,
      {
        "Retry-After": retryAfter.toString(),
      }
    );
  },
});
```

**Bypass Rate Limiting for Internal Services:**

```typescript
import { rateLimiter } from "hono-rate-limiter";

const rateLimiterWithBypass = rateLimiter({
  windowMs: 60 * 1000,
  limit: 100,
  standardHeaders: "draft-7",
  skip: (c) => {
    // Bypass rate limiting for internal service tokens
    const token = c.req.header("x-internal-token");
    if (token === process.env.INTERNAL_SERVICE_TOKEN) {
      return true;
    }

    // Bypass for health checks
    const path = c.req.path;
    if (path === "/health" || path === "/readiness") {
      return true;
    }

    return false;
  },
  keyGenerator: (c) => {
    const payload = c.get("jwtPayload");
    return `user:${payload?.sub || "anonymous"}`;
  },
});
```

**Development vs Production Configuration:**

```typescript
import { rateLimiter } from "hono-rate-limiter";

const isDevelopment = process.env.NODE_ENV === "development";

// More lenient limits in development to avoid hindering local testing
const limit = isDevelopment ? 1000 : 100;

const rateLimiterMiddleware = rateLimiter({
  windowMs: 60 * 1000,
  limit,
  standardHeaders: "draft-7",
  keyGenerator: (c) => {
    const payload = c.get("jwtPayload");
    return `user:${payload?.sub || "anonymous"}`;
  },
});

app.use("*", rateLimiterMiddleware);
```

**Documenting Rate Limits in OpenAPI:**

```typescript
import { createRoute, z } from "@hono/zod-openapi";

const getUserRoute = createRoute({
  method: "get",
  path: "/users/{id}",
  summary: "Get user by ID",
  description:
    "Retrieve detailed information about a specific user. " +
    "Rate limit: 100 requests per minute per user.",
  tags: ["Users"],
  responses: {
    200: {
      description: "User found successfully",
      headers: {
        "X-RateLimit-Limit": {
          description: "Maximum number of requests allowed in the time window",
          schema: { type: "integer", example: 100 },
        },
        "X-RateLimit-Remaining": {
          description:
            "Number of requests remaining in the current time window",
          schema: { type: "integer", example: 95 },
        },
        "X-RateLimit-Reset": {
          description: "Time when the rate limit resets (Unix timestamp)",
          schema: { type: "integer", example: 1640000000 },
        },
      },
      content: {
        "application/json": {
          schema: UserSchema,
        },
      },
    },
    429: {
      description: "Rate limit exceeded",
      headers: {
        "Retry-After": {
          description: "Number of seconds to wait before retrying",
          schema: { type: "integer", example: 60 },
        },
      },
      content: {
        "application/json": {
          schema: z.object({
            error: z.string(),
            message: z.string(),
            retryAfter: z.number().optional(),
          }),
        },
      },
    },
  },
});
```

**Rate Limiting Monitoring:**

```typescript
import { rateLimiter } from "hono-rate-limiter";

const rateLimiterWithLogging = rateLimiter({
  windowMs: 60 * 1000,
  limit: 100,
  standardHeaders: "draft-7",
  keyGenerator: (c) => {
    const payload = c.get("jwtPayload");
    return `user:${payload?.sub || "anonymous"}`;
  },
  handler: (c, _next, options) => {
    // Log rate limit violations for security monitoring
    const userId = c.get("jwtPayload")?.sub || "anonymous";
    const path = c.req.path;
    const method = c.req.method;
    const ip =
      c.req.header("x-forwarded-for") || c.req.header("x-real-ip") || "unknown";

    console.warn("Rate limit exceeded - potential attack", {
      userId,
      ip,
      path,
      method,
      timestamp: new Date().toISOString(),
      limit: options.max,
      window: options.windowMs,
    });

    // Send to monitoring service (e.g., Sentry)
    // Sentry.captureMessage("Rate limit exceeded", {
    //   level: "warning",
    //   extra: { userId, ip, path, method },
    // });

    return c.json(
      {
        error: "Rate limit exceeded",
        message: "Too many requests. Please try again later.",
      },
      429
    );
  },
});
```

**Testing Rate Limiting:**

```typescript
import { describe, it, expect } from "bun:test";
import { app } from "./index";

describe("Rate Limiting", () => {
  it("should allow requests within rate limit", async () => {
    const token = generateTestToken({ sub: "user-123" });

    // Make 5 requests (within limit of 100)
    for (let i = 0; i < 5; i++) {
      const res = await app.request("/api/users", {
        headers: { Authorization: `Bearer ${token}` },
      });
      expect(res.status).toBe(200);
    }
  });

  it("should block requests exceeding rate limit", async () => {
    const token = generateTestToken({ sub: "user-123" });

    // Make requests up to limit
    for (let i = 0; i < 100; i++) {
      await app.request("/api/users", {
        headers: { Authorization: `Bearer ${token}` },
      });
    }

    // Next request should be rate limited
    const res = await app.request("/api/users", {
      headers: { Authorization: `Bearer ${token}` },
    });

    expect(res.status).toBe(429);
    expect(res.headers.get("Retry-After")).toBeDefined();

    const body = await res.json();
    expect(body.error).toContain("Rate limit");
  });

  it("should include rate limit headers in responses", async () => {
    const token = generateTestToken({ sub: "user-123" });

    const res = await app.request("/api/users", {
      headers: { Authorization: `Bearer ${token}` },
    });

    expect(res.headers.get("X-RateLimit-Limit")).toBe("100");
    expect(res.headers.get("X-RateLimit-Remaining")).toBeDefined();
    expect(res.headers.get("X-RateLimit-Reset")).toBeDefined();
  });

  it("should apply stricter limits to auth endpoints", async () => {
    // Auth endpoints have limit of 5 per minute
    for (let i = 0; i < 5; i++) {
      await app.request("/api/auth/login", {
        method: "POST",
        body: JSON.stringify({ email: "test@example.com", password: "pass" }),
      });
    }

    // Next auth attempt should be rate limited
    const res = await app.request("/api/auth/login", {
      method: "POST",
      body: JSON.stringify({ email: "test@example.com", password: "pass" }),
    });
    expect(res.status).toBe(429);
  });

  it("should isolate rate limits per user", async () => {
    const token1 = generateTestToken({ sub: "user-1" });
    const token2 = generateTestToken({ sub: "user-2" });

    // Exhaust rate limit for user 1
    for (let i = 0; i < 100; i++) {
      await app.request("/api/users", {
        headers: { Authorization: `Bearer ${token1}` },
      });
    }

    // User 1 should be rate limited
    let res = await app.request("/api/users", {
      headers: { Authorization: `Bearer ${token1}` },
    });
    expect(res.status).toBe(429);

    // User 2 should still be allowed
    res = await app.request("/api/users", {
      headers: { Authorization: `Bearer ${token2}` },
    });
    expect(res.status).toBe(200);
  });
});
```

**Environment Variables (.env.example):**

```bash
# Rate Limiting Configuration
RATE_LIMIT_DEFAULT=100        # Default rate limit (requests per minute)
RATE_LIMIT_AUTH=5             # Auth endpoints (stricter to prevent brute force)
RATE_LIMIT_EXPENSIVE=10       # Expensive operations (reports, exports)
RATE_LIMIT_READONLY=200       # Read-only operations (more lenient)
```

### Exceptions

- **Health Check Endpoints:** Health check and monitoring endpoints should bypass rate limiting to ensure uptime monitoring works correctly.
- **Internal Service Communication:** Service-to-service calls within the same system should bypass rate limiting using internal authentication tokens.
- **Webhook Receivers:** Endpoints receiving webhooks from trusted external services may need bypass mechanisms with proper authentication.
- **Administrative Operations:** Emergency administrative endpoints may need to bypass limits with proper authentication and logging.
- Other exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-030: Backend for Frontend (BFF) Architecture](./ADR-030.md)
- [ADR-031: Hono as the Backend Framework](./ADR-031.md)
- [ADR-035: Azure AD Authentication and Authorization](./ADR-035.md)
- [hono-rate-limiter Documentation](https://github.com/rhinobase/hono-rate-limiter)
- [RFC 6585 - Additional HTTP Status Codes (429 Too Many Requests)](https://datatracker.ietf.org/doc/html/rfc6585#section-4)
- [IETF Draft - RateLimit Header Fields](https://datatracker.ietf.org/doc/html/draft-ietf-httpapi-ratelimit-headers)
- [OWASP API Security - Rate Limiting](https://owasp.org/API-Security/editions/2023/en/0xa4-unrestricted-resource-consumption/)
