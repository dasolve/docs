# ADR-019: TanStack Query for Data Fetching and Caching

## Context

Modern web applications require efficient data fetching, caching, and synchronization with backend APIs. Traditional approaches have significant limitations:

- **Manual fetch with useState/useEffect:** Requires boilerplate code for loading states, error handling, and cache management
- **Global state libraries:** Not designed for server state, leading to stale data and complex synchronization logic
- **No caching:** Repeated requests for the same data waste bandwidth and slow down the application
- **Race conditions:** Multiple simultaneous requests can cause inconsistent UI state
- **No background updates:** Data becomes stale with no automatic refresh mechanism

For **enterprise applications** with long-running sessions (hours or days), proper data management is critical:

- **Stale Data Prevention:** Long sessions mean data can become outdated; automatic background refetching keeps the UI fresh
- **Optimistic Updates:** Fast, responsive UI updates improve user experience during data mutations
- **Offline Resilience:** Cached data enables the application to function during temporary network issues
- **Performance:** Intelligent caching reduces unnecessary API calls and improves perceived performance
- **Developer Experience:** Declarative data fetching reduces boilerplate and simplifies component logic

Without a standardized data fetching solution, projects would implement inconsistent patterns, duplicate caching logic, and struggle with data synchronization issues.

## Decision

All **frontends built on the Dasolve framework** must use **TanStack Query** for data fetching, caching, and server state management.

TanStack Query will be configured with:

- **Query hooks** for GET requests and data fetching
- **Mutation hooks** for POST/PUT/PATCH/DELETE operations
- **Automatic caching** with configurable stale time and cache time
- **Background refetching** to keep data fresh in long-running sessions
- **Optimistic updates** for immediate UI feedback
- **Error and loading state management** built-in
- **Integration with TanStack Router** loaders for coordinated data loading

This decision ensures all Dasolve frontends have consistent, efficient data fetching with excellent developer experience and optimal performance.

## Do's and Don'ts

### Do

- **DO** use TanStack Query hooks (`useQuery`, `useMutation`, `useInfiniteQuery`) for all data fetching.
- **DO** define query keys as constants or factory functions to ensure consistency and type safety.
- **DO** leverage automatic caching and background refetching to keep data fresh in long-running sessions.
- **DO** implement optimistic updates for mutations to provide immediate user feedback.
- **DO** use query invalidation to update related data after mutations.
- **DO** configure stale time appropriately based on data volatility (longer for static data, shorter for dynamic data).
- **DO** use the `enabled` option to conditionally fetch data based on user actions or route state.
- **DO** implement error boundaries and error handling for failed queries.
- **DO** use TanStack Query DevTools in development to inspect cache state and query behavior.

### Don't

- **DON'T** use raw `fetch` or `axios` calls with `useState` and `useEffect` for data fetching.
- **DON'T** store server data in global state (Jotai, Redux, etc.). Use TanStack Query for server state.
- **DON'T** fetch the same data multiple times. Use query keys to share cached data across components.
- **DON'T** forget to invalidate or refetch queries after mutations that change server state.
- **DON'T** set extremely short stale times that cause excessive refetching and API load.
- **DON'T** ignore loading and error states. Always handle both cases appropriately.
- **DON'T** perform data wrangling or transformations in the frontend. Backend should return data ready for consumption (per Principle 3.13).

## Consequences

### Positive

- **Automatic Caching:** Eliminates duplicate requests and improves performance by caching query results.
- **Background Refetching:** Keeps data fresh in long-running sessions by automatically refetching stale data.
- **Declarative API:** Simple, declarative hooks reduce boilerplate compared to manual fetch logic.
- **Built-in State Management:** Loading, error, and success states are managed automatically.
- **Optimistic Updates:** Enables instant UI feedback during mutations with automatic rollback on errors.
- **Request Deduplication:** Multiple components requesting the same data trigger only one network request.
- **Garbage Collection:** Automatically removes unused cached data to prevent memory leaks.
- **DevTools:** Excellent debugging experience with TanStack Query DevTools.
- **TypeScript Support:** Full type safety for query data, parameters, and errors.
- **Integration:** Seamless integration with TanStack Router ([ADR-017](./ADR-017.md)) and backend type safety ([ADR-025](./ADR-025.md)).

### Negative

- **Learning Curve:** Developers must learn TanStack Query concepts (queries, mutations, cache keys, invalidation).
- **Bundle Size:** Adds to the bundle size, though the benefits far outweigh this cost.
- **Over-fetching Risk:** Automatic background refetching might cause unnecessary API calls if not configured properly.
- **Cache Complexity:** Managing cache invalidation and query dependencies can become complex in large applications.

### Risks

- **Memory Leaks in Long Sessions:** Improper cache configuration could accumulate stale data in long-running sessions. This will be mitigated by:
  - Setting appropriate `gcTime` (garbage collection time) values
  - Monitoring memory usage in development
  - Implementing cache size limits if needed
- **Stale Data Issues:** Incorrect stale time configuration could show outdated data. This will be mitigated by:
  - Setting conservative stale times by default
  - Implementing manual refetch triggers where needed
  - Using query invalidation after mutations

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve frontend scaffolding will include TanStack Query pre-configured with:
  - QueryClient setup with appropriate defaults
  - QueryClientProvider wrapping the application
  - DevTools enabled in development
  - Example queries and mutations
- **Default Configuration:**

  ```typescript
  import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
  import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 60 * 1000, // 5 minutes
        gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)
        retry: 1,
        refetchOnWindowFocus: true,
        refetchOnReconnect: true,
      },
    },
  });

  function App() {
    return (
      <QueryClientProvider client={queryClient}>
        <YourApp />
        {import.meta.env.DEV && <ReactQueryDevtools />}
      </QueryClientProvider>
    );
  }
  ```

- **Code Reviews:** Reviewers must ensure:
  - All data fetching uses TanStack Query hooks
  - Query keys are properly defined and consistent
  - Mutations invalidate related queries
  - No manual fetch/axios calls with useState/useEffect
  - Proper error and loading state handling
- **ESLint Rules:** Custom rules will detect and flag manual data fetching patterns.

### Query Organization

All TanStack Query hooks should be organized in the `src/queries/` directory:

```
src/
├── queries/           # TanStack Query hooks
│   ├── users.ts       # User-related queries and mutations
│   ├── products.ts    # Product-related queries and mutations
│   └── index.ts       # Re-exports all queries
├── pages/
├── components/
└── api/
    └── client.ts      # Hono RPC client
```

### Standard Query Example

Example query file (`src/queries/users.ts`):

```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "../api/client"; // Hono RPC client (ADR-025)

// Query keys factory
export const userKeys = {
  all: ["users"] as const,
  lists: () => [...userKeys.all, "list"] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, "detail"] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

// Fetch user query
export function useUser(userId: string) {
  return useQuery({
    queryKey: userKeys.detail(userId),
    queryFn: async () => {
      const response = await apiClient.users[":id"].$get({
        param: { id: userId },
      });
      return response.json();
    },
  });
}

// Update user mutation
export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, data }: { id: string; data: UpdateUserData }) => {
      const response = await apiClient.users[":id"].$patch({
        param: { id },
        json: data,
      });
      return response.json();
    },
    onSuccess: (data, variables) => {
      // Invalidate and refetch
      queryClient.invalidateQueries({
        queryKey: userKeys.detail(variables.id),
      });
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}
```

Usage in a component:

```typescript
import { useUser, useUpdateUser } from "../queries/users";

function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading } = useUser(userId);
  const updateUser = useUpdateUser();

  // Component logic...
}
```

### Exceptions

- Simple, one-time data fetches that don't benefit from caching may use direct API calls, but this should be rare.
- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-016: React.JS Framework](./ADR-016.md)
- [ADR-018: TanStack Router](./ADR-018.md)
- [ADR-020: Jotai State Management](./ADR-020.md)
- [ADR-025: End-to-End Type Safety](./ADR-025.md)
- [TanStack Query Documentation](https://tanstack.com/query/latest)
- [TanStack Query Best Practices](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)
