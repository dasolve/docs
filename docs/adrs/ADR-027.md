# ADR-027: Optimistic Updates for Mutations

## Context

In traditional web applications, mutations (create, update, delete operations) follow a pessimistic flow:

1. User performs an action (e.g., clicks "Save")
2. Application shows loading state
3. Request is sent to the server
4. Application waits for server response
5. UI updates after receiving confirmation

This approach creates **perceived lag** that degrades user experience:

- **Waiting for Network:** Users must wait for the round-trip to the server, which can take hundreds of milliseconds or even seconds on slower connections
- **Unresponsive UI:** The application feels sluggish as every action requires waiting for server confirmation
- **Poor User Experience:** Users lose confidence when the interface doesn't respond immediately to their actions
- **Reduced Productivity:** In enterprise applications with frequent data updates, this waiting time accumulates and significantly impacts productivity

For **enterprise applications** where users perform many mutations during long-running sessions (hours or days), this traditional approach becomes particularly problematic:

- **High Interaction Frequency:** Users are constantly creating, updating, and deleting data throughout their workday
- **Data Entry Workflows:** Multi-step forms and data entry tasks become tedious when every save requires waiting
- **Expectation of Responsiveness:** Modern users expect applications to feel as responsive as native desktop applications
- **Productivity Impact:** Waiting for server confirmation after every action wastes significant time over extended sessions

Modern applications solve this with **optimistic updates**, where:

1. UI updates immediately when the user performs an action
2. Request is sent to the server in the background
3. If successful, the change is confirmed
4. If it fails, the UI rolls back to the previous state and shows an error

This pattern provides instant feedback while maintaining data integrity through automatic rollback on failure.

### Why Optimistic Updates Matter

- **Instant Feedback:** UI responds immediately to user actions, creating a more satisfying interaction
- **Better UX:** Applications feel faster and more responsive, even on slower connections
- **Perceived Performance:** Users don't notice network latency because the UI updates instantly
- **Increased Productivity:** No waiting between actions allows users to work at their natural pace
- **Modern Expectations:** Users expect the responsiveness they experience in native apps and modern web apps

However, optimistic updates introduce complexity:

- **Rollback Logic:** Must handle reverting UI state when operations fail
- **Error Handling:** Need clear communication when optimistic updates are rolled back
- **State Management:** Must track previous state to enable rollback
- **Conflict Resolution:** Handling cases where optimistic updates conflict with server state

Without a standardized approach to optimistic updates, teams would implement inconsistent patterns, create brittle rollback logic, and provide inconsistent user experiences.

## Decision

All **frontends built on the Dasolve framework** must implement **optimistic updates** for mutations using TanStack Query's built-in optimistic update features.

This means:

- **Immediate UI Updates:** UI updates instantly when a user performs a mutation, before the server responds
- **Background Requests:** Server requests happen in the background while the UI already reflects the change
- **Automatic Rollback:** If the server request fails, TanStack Query automatically reverts the UI to the previous state
- **Error Communication:** Clear error messages are shown to users when optimistic updates fail and are rolled back
- **Query Invalidation:** After successful mutations, related queries are invalidated to ensure data consistency

### When to Use Optimistic Updates

Optimistic updates should be used for:

- **User-initiated mutations:** Creating, updating, or deleting user-generated content
- **Non-critical operations:** Actions where temporary inconsistency is acceptable
- **High-frequency actions:** Operations users perform repeatedly during their session
- **Predictable outcomes:** Mutations where the server response is usually successful

### When NOT to Use Optimistic Updates

Optimistic updates should **NOT** be used for:

- **Financial transactions:** Money transfers, payments, or billing operations
- **Critical state changes:** Operations with significant consequences (e.g., user role changes, account deletions)
- **Complex validations:** Mutations where server-side validation might fail unpredictably
- **External integrations:** Operations dependent on third-party APIs that may fail
- **Audit-critical operations:** Actions requiring confirmed success for compliance

For these cases, use traditional pessimistic updates with loading states and wait for server confirmation before updating the UI.

## Do's and Don'ts

### Do

- **DO** implement optimistic updates for all user-initiated, non-critical mutations (create, update, delete).
- **DO** use TanStack Query's `onMutate` callback to perform optimistic updates.
- **DO** store the previous state in `onMutate` to enable rollback on error.
- **DO** use `onError` to roll back the optimistic update by restoring the previous state and show error notifications.
- **DO** use `onSettled` to invalidate related queries after both success and error cases.
- **DO** use `onSuccess` only when you need to show success feedback (toasts, notifications) to the user.
- **DO** provide clear error messages when optimistic updates fail and are rolled back.
- **DO** use loading indicators to show that the server request is in progress (even though UI already updated).
- **DO** test error scenarios to ensure rollback works correctly.

### Don't

- **DON'T** use optimistic updates for critical operations like financial transactions or irreversible actions.
- **DON'T** forget to implement rollback logic in the `onError` callback.
- **DON'T** assume the optimistic update will always succeed. Always handle errors.
- **DON'T** invalidate queries in `onSuccess` - use `onSettled` instead to ensure queries are refetched after both success and error.
- **DON'T** update the UI without tracking the previous state for rollback.
- **DON'T** ignore the mutation's loading state. Show subtle indicators that the operation is processing.
- **DON'T** use optimistic updates for operations with complex server-side validation.
- **DON'T** implement optimistic updates manually with useState. Use TanStack Query's built-in features.

## Consequences

### Positive

- **Superior User Experience:** Instant UI feedback makes applications feel fast and responsive.
- **Increased Productivity:** Users can work at their natural pace without waiting for server confirmation.
- **Better Perceived Performance:** Even on slower connections, the application feels snappy.
- **Modern User Expectations:** Meets the responsiveness standards users expect from modern web applications.
- **Reduced Frustration:** Eliminates the frustration of waiting for every action to complete.
- **Seamless Workflows:** Multi-step data entry and editing workflows feel fluid and natural.
- **Built-in Safety:** TanStack Query's automatic rollback ensures data integrity when operations fail.

### Negative

- **Increased Complexity:** Requires implementing and testing rollback logic for all mutations.
- **Potential Confusion:** Users might be confused if an optimistic update is rolled back after they've moved on to another task.
- **Testing Requirements:** Must test both success and failure scenarios, including rollback behavior.
- **State Management Overhead:** Must track previous state for all optimistic updates.

### Risks

- **User Confusion on Rollback:** Users might not notice when an optimistic update is rolled back, leading to confusion about the actual state. This will be mitigated by:
  - Showing clear, prominent error notifications when rollbacks occur
  - Using toast notifications or alerts that demand user attention
  - Highlighting the affected items in the UI when rollback happens
  - Providing actionable error messages that explain what failed and how to retry
- **Race Conditions:** Multiple rapid mutations on the same data could create inconsistent state. This will be mitigated by:
  - Using proper query keys to scope optimistic updates
  - Implementing debouncing for high-frequency updates
  - Leveraging TanStack Query's mutation queue to serialize related mutations
  - Testing race condition scenarios in development

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve frontend scaffolding will include example mutations with optimistic updates demonstrating best practices.
- **Code Reviews:** Reviewers must ensure:
  - All non-critical mutations implement optimistic updates
  - Rollback logic is properly implemented in `onError`
  - Previous state is captured in `onMutate`
  - Queries are invalidated in `onSuccess`
  - Error messages are clear and actionable
  - Critical operations (financial, irreversible) do NOT use optimistic updates
- **Testing Requirements:** All mutations must have tests covering:
  - Success scenario with optimistic update
  - Error scenario with rollback
  - Query invalidation after success
- **Documentation:** Each mutation should document why it does or doesn't use optimistic updates.

### Standard Pattern Examples

#### Mutation Callback Flow

The correct flow for optimistic updates uses three callbacks:

1. **`onMutate`** (required): Perform the optimistic update and return context for rollback
2. **`onError`** (required): Roll back the optimistic update using the context and show error notification
3. **`onSettled`** (required): Invalidate queries to refetch fresh data (runs after both success and error)
4. **`onSuccess`** (optional): Only use this if you need to show success feedback to the user (e.g., toast notifications)

**✅ CORRECT: Optimistic update for editing a user (with user feedback)**

```typescript
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "../api/client";
import { userKeys } from "./users";

export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, data }: { id: string; data: UpdateUserData }) => {
      const response = await apiClient.users[":id"].$patch({
        param: { id },
        json: data,
      });
      return response.json();
    },

    // Optimistic update: Update UI immediately
    onMutate: async ({ id, data }) => {
      // Cancel any outgoing refetches to avoid overwriting our optimistic update
      await queryClient.cancelQueries({ queryKey: userKeys.detail(id) });

      // Snapshot the previous value for rollback
      const previousUser = queryClient.getQueryData(userKeys.detail(id));

      // Optimistically update the cache
      queryClient.setQueryData(userKeys.detail(id), (old: any) => ({
        ...old,
        ...data,
      }));

      // Return context with the previous value for rollback
      return { previousUser, userId: id };
    },

    // On error: Roll back and notify user
    onError: (err, variables, context) => {
      if (context?.previousUser) {
        queryClient.setQueryData(
          userKeys.detail(context.userId),
          context.previousUser
        );
      }
      toast.error("Failed to update user. Changes have been reverted.");
    },

    // On success: Optional - only for user feedback
    onSuccess: () => {
      toast.success("User updated successfully!");
    },

    // Always refetch after error or success
    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({
        queryKey: userKeys.detail(variables.id),
      });
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}
```

**✅ CORRECT: Optimistic delete from a list (without user feedback)**

```typescript
export function useDeleteUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (userId: string) => {
      const response = await apiClient.users[":id"].$delete({
        param: { id: userId },
      });
      return response.json();
    },

    onMutate: async (userId) => {
      await queryClient.cancelQueries({ queryKey: userKeys.lists() });
      const previousUsers = queryClient.getQueryData(userKeys.lists());

      // Optimistically remove user from list
      queryClient.setQueryData(userKeys.lists(), (old: any) => ({
        ...old,
        users: old.users.filter((user: any) => user.id !== userId),
      }));

      return { previousUsers };
    },

    onError: (err, userId, context) => {
      if (context?.previousUsers) {
        queryClient.setQueryData(userKeys.lists(), context.previousUsers);
      }
      toast.error("Failed to delete user. User has been restored.");
    },

    // onSuccess omitted - no user feedback needed, onSettled handles refetch

    // Always refetch after error or success
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}
```

**✅ CORRECT: Optimistic create (with success notification)**

```typescript
export function useCreateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: CreateUserData) => {
      const response = await apiClient.users.$post({
        json: data,
      });
      return response.json();
    },

    onMutate: async (newUser) => {
      await queryClient.cancelQueries({ queryKey: userKeys.lists() });
      const previousUsers = queryClient.getQueryData(userKeys.lists());

      // Optimistically add the new user with a temporary ID
      queryClient.setQueryData(userKeys.lists(), (old: any) => ({
        ...old,
        users: [
          ...old.users,
          {
            id: `temp-${Date.now()}`, // Temporary ID
            ...newUser,
          },
        ],
      }));

      return { previousUsers };
    },

    onError: (err, newUser, context) => {
      if (context?.previousUsers) {
        queryClient.setQueryData(userKeys.lists(), context.previousUsers);
      }
      toast.error("Failed to create user. Please try again.");
    },

    // Optional: Show success feedback
    onSuccess: () => {
      toast.success("User created successfully!");
    },

    // Always refetch to get the real ID from server
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}
```

**✅ CORRECT: Using the mutation in a component**

```typescript
function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading } = useUser(userId);
  const updateUser = useUpdateUser();

  const handleSave = (formData: UpdateUserData) => {
    updateUser.mutate(
      { id: userId, data: formData },
      {
        onSuccess: () => {
          // Additional success handling if needed
        },
        onError: (error) => {
          // Additional error handling if needed
          console.error("Update failed:", error);
        },
      }
    );
  };

  if (isLoading) return <div>Loading...</div>;

  return (
    <form onSubmit={handleSubmit(handleSave)}>
      {/* Form fields here */}
      <button type="submit" disabled={updateUser.isPending}>
        {updateUser.isPending ? "Saving..." : "Save"}
      </button>
    </form>
  );
}
```

**❌ INCORRECT: Not implementing optimistic updates**

```typescript
// ❌ BAD: Waiting for server response before updating UI
export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, data }: { id: string; data: UpdateUserData }) => {
      const response = await apiClient.users[":id"].$patch({
        param: { id },
        json: data,
      });
      return response.json();
    },
    // Missing onMutate - no optimistic update!
    onSettled: (data, error, variables) => {
      // Only updates UI after server responds
      queryClient.invalidateQueries({
        queryKey: userKeys.detail(variables.id),
      });
    },
  });
}
```

**❌ INCORRECT: Invalidating queries in onSuccess instead of onSettled**

```typescript
// ❌ BAD: Queries not refetched on error
export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, data }: { id: string; data: UpdateUserData }) => {
      const response = await apiClient.users[":id"].$patch({
        param: { id },
        json: data,
      });
      return response.json();
    },

    onMutate: async ({ id, data }) => {
      await queryClient.cancelQueries({ queryKey: userKeys.detail(id) });
      const previousUser = queryClient.getQueryData(userKeys.detail(id));
      queryClient.setQueryData(userKeys.detail(id), (old: any) => ({
        ...old,
        ...data,
      }));
      return { previousUser, userId: id };
    },

    onError: (err, variables, context) => {
      if (context?.previousUser) {
        queryClient.setQueryData(
          userKeys.detail(context.userId),
          context.previousUser
        );
      }
    },

    // ❌ BAD: Should use onSettled instead
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({
        queryKey: userKeys.detail(variables.id),
      });
    },
  });
}
```

**❌ INCORRECT: Using optimistic updates for critical operations**

```typescript
// ❌ BAD: Optimistic update for financial transaction
export function useTransferMoney() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ from, to, amount }) => {
      // ... transfer money
    },
    // DON'T do optimistic updates for financial operations!
    onMutate: async ({ from, to, amount }) => {
      // This is dangerous - money transfers need server confirmation
      queryClient.setQueryData(accountKeys.detail(from), (old: any) => ({
        ...old,
        balance: old.balance - amount,
      }));
    },
  });
}
```

### UI Feedback Best Practices

When implementing optimistic updates, provide appropriate UI feedback:

```typescript
function UserList() {
  const { data } = useUsers();
  const deleteUser = useDeleteUser();

  return (
    <div>
      {data?.users.map((user) => (
        <div key={user.id}>
          {user.name}
          <button
            onClick={() => deleteUser.mutate(user.id)}
            disabled={deleteUser.isPending}
          >
            {deleteUser.isPending && deleteUser.variables === user.id
              ? "Deleting..."
              : "Delete"}
          </button>
        </div>
      ))}
    </div>
  );
}
```

### Error Notification Pattern

Use a toast/notification library to communicate rollbacks:

```typescript
import { toast } from "react-hot-toast"; // or your preferred toast library

export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    // ... mutation config

    onError: (err, variables, context) => {
      // Rollback
      if (context?.previousUser) {
        queryClient.setQueryData(
          userKeys.detail(context.userId),
          context.previousUser
        );
      }

      // Show prominent error notification
      toast.error(
        <div>
          <strong>Failed to update user</strong>
          <p>Your changes have been reverted. Please try again.</p>
        </div>,
        {
          duration: 5000, // Show for 5 seconds
          icon: "⚠️",
        }
      );
    },

    onSuccess: () => {
      toast.success("User updated successfully!", {
        duration: 3000,
        icon: "✓",
      });
    },
  });
}
```

### Exceptions

- **Critical Operations:** Financial transactions, user role changes, account deletions, and other high-stakes operations should NOT use optimistic updates. These operations must wait for server confirmation before updating the UI.
- **Complex Validations:** Mutations with complex server-side validation that might fail unpredictably should use pessimistic updates with loading states.
- **Third-Party Integrations:** Operations that depend on external APIs should not use optimistic updates, as failure rates may be higher.
- All approved exceptions must be documented in code comments explaining why optimistic updates are not used.

## References

- [ADR-019: TanStack Query for Data Fetching](ADR-019.md)
- [ADR-025: End-to-End Type Safety](ADR-025.md)
- [ADR-026: No Client-Side Data Wrangling](ADR-026.md)
- [TanStack Query Optimistic Updates Guide](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
- [TanStack Query Mutations Documentation](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
