# ADR-034: OpenAPI Documentation for Backends

## Context

API documentation is critical for maintaining, consuming, and evolving backend services. While end-to-end type safety through Hono RPC ([ADR-032](./ADR-032.md)) provides excellent developer experience for TypeScript clients, comprehensive API documentation serves multiple additional purposes:

- **Team Communication:** Enables clear communication between frontend and backend teams about API contracts
- **Third-Party Integration:** External systems and partners need standardized documentation to integrate with APIs
- **Testing and Validation:** QA teams and automated testing tools need clear API specifications
- **Monitoring and Observability:** API documentation helps with setting up monitoring, logging, and alerting
- **Onboarding:** New developers can understand the API surface quickly without diving into code
- **Client Generation:** Other language clients (Python, Java, Go, etc.) can be generated from specifications
- **API Evolution:** Tracks changes over time and helps maintain backwards compatibility

Traditional approaches to API documentation include:

- **Manual Documentation:** Writing docs separately from code leads to documentation drift and maintenance burden
- **README Files:** Markdown files become outdated quickly and lack standardization
- **Postman Collections:** Proprietary format, requires manual updates, not suitable for automated workflows
- **Code Comments:** Insufficient for comprehensive API documentation and discovery
- **Custom Documentation Sites:** Require significant development and maintenance effort

For **enterprise applications** built on the Dasolve framework:

- **Standardization:** APIs must follow industry-standard documentation formats
- **Automated Generation:** Documentation should be generated from code to prevent drift
- **Interactive Exploration:** Teams need to test APIs directly from documentation
- **Version Control:** API changes must be tracked alongside code changes
- **Integration Ready:** Documentation must support client code generation for various languages
- **Security Documentation:** Authentication, authorization, and rate limiting must be clearly documented

**OpenAPI Specification (formerly Swagger)** is the industry standard for RESTful API documentation. It provides:

1. **Machine-Readable Format:** JSON/YAML specifications that tools can parse
2. **Wide Ecosystem:** Extensive tooling for documentation generation, client generation, testing, and validation
3. **Interactive UI:** Swagger UI and similar tools provide interactive API exploration
4. **Code Generation:** Client libraries can be generated for multiple languages
5. **Validation:** Requests and responses can be validated against the specification

Since Dasolve backends use **Zod schemas for validation** ([ADR-032](./ADR-032.md)), these schemas can be automatically converted to OpenAPI specifications, ensuring:

- Documentation is always synchronized with actual validation rules
- Single source of truth for API contracts
- No manual maintenance of documentation
- Type-safe integration between code and docs

## Decision

All **backends built on the Dasolve framework** must:

1. **Generate OpenAPI Specifications** from Zod schemas and route definitions
2. **Use @hono/zod-openapi** to create OpenAPI-compatible routes
3. **Expose OpenAPI JSON** at a standard endpoint (`/openapi.json`)
4. **Provide Interactive Documentation** via Scalar at a standard endpoint (`/docs`)
5. **Include Complete Metadata** such as API title, version, description, and contact information
6. **Document Authentication** including Azure AD integration and required scopes
7. **Document Error Responses** with examples for common error scenarios
8. **Version APIs Appropriately** using semantic versioning

This ensures:

- **Automated Documentation:** Generated from code, preventing documentation drift
- **Interactive Exploration:** Teams can test APIs directly from browser
- **Multi-Language Support:** Clients can be generated for any language
- **Standard Format:** Industry-standard OpenAPI/Swagger specification
- **Developer Experience:** Clear, comprehensive, always-up-to-date documentation

## Do's and Don'ts

### Do

- **DO** use `@hono/zod-openapi` to define routes with OpenAPI metadata.
- **DO** generate OpenAPI specifications from Zod schemas to ensure synchronization.
- **DO** expose OpenAPI JSON at `/openapi.json`.
- **DO** provide Scalar documentation at `/docs` for interactive exploration.
- **DO** include comprehensive metadata: title, version, description, contact info, license.
- **DO** document all authentication requirements, including Azure AD scopes.
- **DO** provide examples for request bodies, responses, and error cases.
- **DO** document all error responses with appropriate status codes.
- **DO** use semantic versioning for API versions (e.g., `1.0.0`, `1.1.0`).
- **DO** group related endpoints with tags for better organization.
- **DO** include descriptions for all routes, parameters, and response fields.
- **DO** document rate limiting, pagination, and other operational concerns.
- **DO** update API version when making breaking changes.

### Don't

- **DON'T** maintain separate documentation files that can drift from code.
- **DON'T** skip documenting error responses—they're critical for consumers.
- **DON'T** expose Scalar documentation in production without authentication (unless intentionally public).
- **DON'T** use generic descriptions like "Get data" or "Update resource."
- **DON'T** forget to document authentication and authorization requirements.
- **DON'T** omit examples—they significantly improve documentation usability.
- **DON'T** use inconsistent naming conventions across endpoints.
- **DON'T** forget to update the version number when making API changes.
- **DON'T** document internal/private endpoints in public OpenAPI specs.
- **DON'T** skip validation—ensure generated specs are valid OpenAPI 3.0+.

## Consequences

### Positive

- **Zero Documentation Drift:** Specifications are generated from code, ensuring accuracy
- **Single Source of Truth:** Zod schemas define both validation and documentation
- **Interactive Testing:** Scalar enables immediate API testing without separate tools
- **Multi-Language Clients:** OpenAPI specs enable client generation for any language
- **Better Onboarding:** New developers can explore and understand APIs quickly
- **Industry Standard:** OpenAPI is widely recognized and supported
- **Automated Workflows:** Specs can be used in CI/CD, testing, and monitoring
- **Clear Communication:** Frontend, backend, and external teams have shared API contract
- **API Evolution:** Changes are tracked through version control
- **Tool Ecosystem:** Extensive tooling for validation, testing, mocking, and monitoring

### Negative

- **Initial Setup Effort:** Migrating from basic Hono routes to OpenAPI routes requires work
- **Verbose Definitions:** OpenAPI route definitions are more verbose than basic Hono routes
- **Learning Curve:** Developers need to learn OpenAPI concepts and `@hono/zod-openapi` patterns
- **Build Overhead:** Generating OpenAPI specs adds minimal build time

### Risks

- **Incomplete Documentation:** Developers might skip optional metadata like descriptions and examples. Mitigated by:
  - Code review requirements for complete documentation
  - Linting rules to enforce descriptions
  - Templates with comprehensive examples
  - Documentation standards in project guidelines
- **Exposure of Internal APIs:** Accidentally documenting internal endpoints. Mitigated by:
  - Separate OpenAPI instances for public vs internal APIs
  - Authentication required for documentation endpoints in production
  - Code reviews checking for appropriate endpoint exposure
- **Breaking Changes:** API changes might break existing clients. Mitigated by:
  - Semantic versioning requirements
  - Deprecation notices in documentation
  - Multiple API versions when needed
  - Change logs tracking breaking changes

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve backend scaffolding will include:
  - `@hono/zod-openapi` pre-configured
  - Example routes with complete OpenAPI metadata
  - Scalar setup at `/docs`
  - OpenAPI JSON endpoint at `/openapi.json`
  - Authentication documentation examples
- **Code Reviews:** Reviewers must ensure:
  - All routes have OpenAPI metadata (summary, description, tags)
  - Authentication requirements are documented
  - Error responses are documented
  - Examples are provided for complex schemas
  - Descriptions are meaningful and complete
- **CI/CD Validation:** Automated checks verify:
  - Generated OpenAPI spec is valid
  - All routes are documented
  - Required metadata fields are present
- **Documentation Standards:** Projects must maintain:
  - API version in `package.json` and OpenAPI spec
  - Changelog documenting API changes
  - Migration guides for breaking changes

### Standard Implementation

**Basic Setup with OpenAPI** (`packages/backend/src/index.ts`):

```typescript
import { OpenAPIHono, createRoute, z } from "@hono/zod-openapi";
import { apiReference } from "@scalar/hono-api-reference";

// Create OpenAPI-enabled Hono app
const app = new OpenAPIHono();

// API metadata
app.doc("/openapi.json", {
  openapi: "3.0.0",
  info: {
    version: "1.0.0",
    title: "Dasolve API",
    description: "Backend API for Dasolve application",
    contact: {
      name: "API Support",
      email: "api@example.com",
    },
    license: {
      name: "MIT",
      url: "https://opensource.org/licenses/MIT",
    },
  },
  servers: [
    {
      url: "http://localhost:3000",
      description: "Development server",
    },
    {
      url: "https://api.example.com",
      description: "Production server",
    },
  ],
  security: [
    {
      BearerAuth: [],
    },
  ],
  components: {
    securitySchemes: {
      BearerAuth: {
        type: "http",
        scheme: "bearer",
        bearerFormat: "JWT",
        description: "Azure AD Bearer token",
      },
    },
  },
});

// Scalar API Reference documentation
app.get(
  "/docs",
  apiReference({
    spec: {
      url: "/openapi.json",
    },
  })
);

// Export for Hono RPC type inference
export type AppType = typeof app;

export default app;
```

**Defining OpenAPI Routes:**

```typescript
import { createRoute, z } from "@hono/zod-openapi";

// Define schemas
const UserSchema = z
  .object({
    id: z.string().uuid().openapi({
      example: "123e4567-e89b-12d3-a456-426614174000",
      description: "User unique identifier",
    }),
    name: z.string().min(1).max(100).openapi({
      example: "John Doe",
      description: "User full name",
    }),
    email: z.string().email().openapi({
      example: "john.doe@example.com",
      description: "User email address",
    }),
    age: z.number().int().positive().optional().openapi({
      example: 30,
      description: "User age in years",
    }),
    createdAt: z.string().datetime().openapi({
      example: "2024-01-15T10:30:00Z",
      description: "User creation timestamp",
    }),
  })
  .openapi("User");

const CreateUserSchema = z
  .object({
    name: z.string().min(1).max(100),
    email: z.string().email(),
    age: z.number().int().positive().optional(),
  })
  .openapi("CreateUser");

const ErrorSchema = z
  .object({
    error: z.string().openapi({
      example: "Validation failed",
      description: "Error message",
    }),
    details: z
      .array(
        z.object({
          path: z.string(),
          message: z.string(),
        })
      )
      .optional()
      .openapi({
        example: [{ path: "email", message: "Invalid email format" }],
        description: "Validation error details",
      }),
  })
  .openapi("Error");

const PaginationQuerySchema = z.object({
  page: z.string().transform(Number).pipe(z.number().int().positive()),
  limit: z.string().transform(Number).pipe(z.number().int().min(1).max(100)),
});

// Define route with OpenAPI metadata
const getUsersRoute = createRoute({
  method: "get",
  path: "/users",
  summary: "List users",
  description: "Retrieve a paginated list of users",
  tags: ["Users"],
  security: [{ BearerAuth: [] }],
  request: {
    query: PaginationQuerySchema,
  },
  responses: {
    200: {
      description: "Successful response with user list",
      content: {
        "application/json": {
          schema: z.object({
            users: z.array(UserSchema),
            pagination: z.object({
              page: z.number().int(),
              limit: z.number().int(),
              total: z.number().int(),
            }),
          }),
        },
      },
    },
    400: {
      description: "Bad request - invalid query parameters",
      content: {
        "application/json": {
          schema: ErrorSchema,
        },
      },
    },
    401: {
      description: "Unauthorized - missing or invalid token",
      content: {
        "application/json": {
          schema: ErrorSchema,
        },
      },
    },
  },
});

// Implement route
app.openapi(getUsersRoute, async (c) => {
  const { page, limit } = c.req.valid("query");

  const users = await db.users.findMany({
    skip: (page - 1) * limit,
    take: limit,
  });

  return c.json({
    users,
    pagination: {
      page,
      limit,
      total: await db.users.count(),
    },
  });
});
```

**Complete CRUD Example with OpenAPI:**

```typescript
import { OpenAPIHono, createRoute, z } from "@hono/zod-openapi";

const app = new OpenAPIHono();

// Schemas
const UserSchema = z
  .object({
    id: z.string().uuid(),
    name: z.string().min(1).max(100),
    email: z.string().email(),
    age: z.number().int().positive().optional(),
  })
  .openapi("User");

const CreateUserSchema = UserSchema.omit({ id: true }).openapi("CreateUser");
const UpdateUserSchema = CreateUserSchema.partial().openapi("UpdateUser");

const UserIdParamSchema = z.object({
  id: z
    .string()
    .uuid()
    .openapi({
      param: {
        name: "id",
        in: "path",
      },
      example: "123e4567-e89b-12d3-a456-426614174000",
    }),
});

const ErrorSchema = z
  .object({
    error: z.string(),
    details: z
      .array(z.object({ path: z.string(), message: z.string() }))
      .optional(),
  })
  .openapi("Error");

// List users
const listUsersRoute = createRoute({
  method: "get",
  path: "/users",
  summary: "List all users",
  description: "Retrieve a paginated list of all users in the system",
  tags: ["Users"],
  request: {
    query: z.object({
      page: z
        .string()
        .transform(Number)
        .pipe(z.number().int().positive().default(1)),
      limit: z
        .string()
        .transform(Number)
        .pipe(z.number().int().min(1).max(100).default(20)),
    }),
  },
  responses: {
    200: {
      description: "List of users retrieved successfully",
      content: {
        "application/json": {
          schema: z.object({
            users: z.array(UserSchema),
            pagination: z.object({
              page: z.number(),
              limit: z.number(),
              total: z.number(),
            }),
          }),
        },
      },
    },
    400: {
      description: "Invalid query parameters",
      content: { "application/json": { schema: ErrorSchema } },
    },
  },
});

app.openapi(listUsersRoute, async (c) => {
  const { page, limit } = c.req.valid("query");
  const users = await db.users.findMany({
    skip: (page - 1) * limit,
    take: limit,
  });

  return c.json({
    users,
    pagination: { page, limit, total: await db.users.count() },
  });
});

// Get single user
const getUserRoute = createRoute({
  method: "get",
  path: "/users/{id}",
  summary: "Get user by ID",
  description: "Retrieve detailed information about a specific user",
  tags: ["Users"],
  request: {
    params: UserIdParamSchema,
  },
  responses: {
    200: {
      description: "User found and returned successfully",
      content: {
        "application/json": {
          schema: UserSchema,
        },
      },
    },
    404: {
      description: "User not found",
      content: { "application/json": { schema: ErrorSchema } },
    },
  },
});

app.openapi(getUserRoute, async (c) => {
  const { id } = c.req.valid("param");
  const user = await db.users.findById(id);

  if (!user) {
    return c.json({ error: "User not found" }, 404);
  }

  return c.json(user);
});

// Create user
const createUserRoute = createRoute({
  method: "post",
  path: "/users",
  summary: "Create a new user",
  description: "Create a new user account in the system",
  tags: ["Users"],
  request: {
    body: {
      content: {
        "application/json": {
          schema: CreateUserSchema,
        },
      },
    },
  },
  responses: {
    201: {
      description: "User created successfully",
      content: {
        "application/json": {
          schema: UserSchema,
        },
      },
    },
    400: {
      description: "Invalid input data",
      content: { "application/json": { schema: ErrorSchema } },
    },
  },
});

app.openapi(createUserRoute, async (c) => {
  const body = c.req.valid("json");
  const newUser = await db.users.create({
    ...body,
    id: crypto.randomUUID(),
  });

  return c.json(newUser, 201);
});

// Update user
const updateUserRoute = createRoute({
  method: "put",
  path: "/users/{id}",
  summary: "Update user",
  description: "Update an existing user's information",
  tags: ["Users"],
  request: {
    params: UserIdParamSchema,
    body: {
      content: {
        "application/json": {
          schema: UpdateUserSchema,
        },
      },
    },
  },
  responses: {
    200: {
      description: "User updated successfully",
      content: {
        "application/json": {
          schema: UserSchema,
        },
      },
    },
    404: {
      description: "User not found",
      content: { "application/json": { schema: ErrorSchema } },
    },
  },
});

app.openapi(updateUserRoute, async (c) => {
  const { id } = c.req.valid("param");
  const body = c.req.valid("json");
  const updatedUser = await db.users.update(id, body);

  return c.json(updatedUser);
});

// Delete user
const deleteUserRoute = createRoute({
  method: "delete",
  path: "/users/{id}",
  summary: "Delete user",
  description: "Permanently delete a user from the system",
  tags: ["Users"],
  request: {
    params: UserIdParamSchema,
  },
  responses: {
    204: {
      description: "User deleted successfully",
    },
    404: {
      description: "User not found",
      content: { "application/json": { schema: ErrorSchema } },
    },
  },
});

app.openapi(deleteUserRoute, async (c) => {
  const { id } = c.req.valid("param");
  await db.users.delete(id);
  return c.body(null, 204);
});
```

**Organizing Routes by Feature:**

```typescript
// features/users/routes.ts
import { OpenAPIHono, createRoute, z } from "@hono/zod-openapi";
import { UserSchema, CreateUserSchema } from "./schemas";

export const usersApp = new OpenAPIHono();

// Define and implement routes
const listRoute = createRoute({
  method: "get",
  path: "/",
  summary: "List users",
  tags: ["Users"],
  responses: {
    200: {
      description: "Users list",
      content: {
        "application/json": {
          schema: z.object({ users: z.array(UserSchema) }),
        },
      },
    },
  },
});

usersApp.openapi(listRoute, async (c) => {
  const users = await db.users.findMany();
  return c.json({ users });
});

// Main app
import { OpenAPIHono } from "@hono/zod-openapi";
import { usersApp } from "./features/users/routes";
import { productsApp } from "./features/products/routes";

const app = new OpenAPIHono();

// Mount feature routers
app.route("/users", usersApp);
app.route("/products", productsApp);

// OpenAPI documentation
app.doc("/openapi.json", {
  openapi: "3.0.0",
  info: {
    version: "1.0.0",
    title: "Dasolve API",
  },
});
```

**Advanced Examples and Descriptions:**

```typescript
import { createRoute, z } from "@hono/zod-openapi";

const SearchQuerySchema = z.object({
  q: z.string().min(1).max(100).openapi({
    description: "Search query string",
    example: "typescript framework",
  }),
  category: z.enum(["all", "users", "products", "orders"]).optional().openapi({
    description: "Limit search to specific category",
    example: "users",
  }),
  sort: z.enum(["relevance", "date", "name"]).default("relevance").openapi({
    description: "Sort order for results",
    example: "relevance",
  }),
  page: z.string().transform(Number).pipe(z.number().int().positive()),
  limit: z.string().transform(Number).pipe(z.number().int().min(1).max(100)),
});

const searchRoute = createRoute({
  method: "get",
  path: "/search",
  summary: "Search across resources",
  description:
    "Perform a full-text search across multiple resource types. " +
    "Returns paginated results sorted by relevance or other criteria. " +
    "Supports filtering by category and custom sorting options.",
  tags: ["Search"],
  request: {
    query: SearchQuerySchema,
  },
  responses: {
    200: {
      description:
        "Search completed successfully. Returns matching results " +
        "with pagination metadata and highlighting information.",
      content: {
        "application/json": {
          schema: z.object({
            results: z.array(
              z.object({
                type: z.enum(["user", "product", "order"]),
                id: z.string(),
                title: z.string(),
                description: z.string(),
                highlights: z.array(z.string()).optional(),
              })
            ),
            pagination: z.object({
              page: z.number(),
              limit: z.number(),
              total: z.number(),
            }),
          }),
        },
      },
    },
    400: {
      description: "Invalid search parameters provided",
      content: {
        "application/json": {
          schema: z.object({
            error: z.string(),
          }),
        },
      },
    },
  },
});
```

**Environment-Specific Documentation:**

```typescript
import { OpenAPIHono } from "@hono/zod-openapi";
import { apiReference } from "@scalar/hono-api-reference";

const app = new OpenAPIHono();

const isDevelopment = Bun.env.MODE === "development";

// Expose docs only in development, or require auth in production
if (isDevelopment) {
  app.get(
    "/docs",
    apiReference({
      spec: {
        url: "/openapi.json",
      },
    })
  );
} else {
  // In production, require authentication for docs
  app.get(
    "/docs",
    async (c, next) => {
      // Check auth token
      const token = c.req.header("Authorization");
      if (!token || !isValidAdminToken(token)) {
        return c.json({ error: "Unauthorized" }, 401);
      }
      await next();
    },
    apiReference({
      spec: {
        url: "/openapi.json",
      },
    })
  );
}

// OpenAPI spec with environment-specific servers
app.doc("/openapi.json", {
  openapi: "3.0.0",
  info: {
    version: "1.0.0",
    title: "Dasolve API",
  },
  servers: isDevelopment
    ? [{ url: "http://localhost:3000", description: "Development" }]
    : [{ url: "https://api.example.com", description: "Production" }],
});
```

**Testing OpenAPI Specification:**

```typescript
import { describe, it, expect } from "bun:test";
import app from "./index";

describe("OpenAPI Documentation", () => {
  it("should expose valid OpenAPI JSON", async () => {
    const res = await app.request("/openapi.json");
    expect(res.status).toBe(200);

    const spec = await res.json();
    expect(spec.openapi).toBe("3.0.0");
    expect(spec.info.title).toBeDefined();
    expect(spec.info.version).toBeDefined();
    expect(spec.paths).toBeDefined();
  });

  it("should document all routes", async () => {
    const res = await app.request("/openapi.json");
    const spec = await res.json();

    // Verify critical routes are documented
    expect(spec.paths["/users"]).toBeDefined();
    expect(spec.paths["/users/{id}"]).toBeDefined();
  });

  it("should include authentication scheme", async () => {
    const res = await app.request("/openapi.json");
    const spec = await res.json();

    expect(spec.components.securitySchemes.BearerAuth).toBeDefined();
    expect(spec.components.securitySchemes.BearerAuth.type).toBe("http");
  });

  it("should serve Scalar documentation", async () => {
    const res = await app.request("/docs");
    expect(res.status).toBe(200);
    expect(res.headers.get("Content-Type")).toContain("text/html");
  });
});
```

### Exceptions

- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-030: Backend for Frontend (BFF) Architecture](./ADR-030.md)
- [ADR-031: Hono as the Backend Framework](./ADR-031.md)
- [ADR-032: Hono RPC and Zod Validation](./ADR-032.md)
- [ADR-033: CORS Support for Backends](./ADR-033.md)
- [@hono/zod-openapi Documentation](https://github.com/honojs/middleware/tree/main/packages/zod-openapi)
- [@scalar/hono-api-reference Documentation](https://github.com/scalar/scalar/tree/main/integrations/hono)
- [Scalar API Reference](https://github.com/scalar/scalar)
- [OpenAPI Specification](https://spec.openapis.org/oas/latest.html)
