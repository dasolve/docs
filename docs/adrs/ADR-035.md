# ADR-035: Azure AD Authentication and Authorization in Backends

## Context

Enterprise backends must authenticate and authorize requests to:

- **Verify user identity** by validating tokens issued by Azure AD
- **Protect API endpoints** from unauthorized access
- **Enforce role-based access control (RBAC)** based on user roles and permissions
- **Integrate with enterprise identity systems** seamlessly with the frontend
- **Comply with security policies** and audit requirements
- **Prevent token tampering** and replay attacks

For **enterprise backends** built on the Dasolve framework:

- **Token Validation Required:** Frontends forward Azure AD access tokens ([ADR-022](./ADR-022.md)) that backends must validate before processing requests
- **Stateless Authentication:** Backends should not maintain session state, relying on JWT tokens for each request
- **Fine-Grained Authorization:** Different endpoints require different permission levels based on user roles
- **Security-First:** All protected endpoints must validate tokens and check permissions before executing business logic
- **Integration with BFF:** The Backend for Frontend ([ADR-030](./ADR-030.md)) must securely validate tokens from its dedicated frontend

Without standardized backend authentication, projects would implement inconsistent security patterns, creating vulnerabilities and making it difficult to maintain proper access controls.

## Decision

All **backends built on the Dasolve framework** must support **Azure Active Directory (Azure AD)** authentication and authorization.

Backend authentication and authorization will be implemented with:

- **JWT token validation** using Azure AD public keys
- **Middleware-based authentication** that validates tokens on protected routes
- **Role-based authorization** using claims from validated tokens
- **Automatic token validation** on every protected endpoint request
- **Clear separation** between public and protected endpoints
- **Error handling** for invalid, expired, or missing tokens
- **Logging and monitoring** of authentication failures for security auditing

This decision ensures all Dasolve backends properly validate tokens forwarded from frontends and enforce authorization policies consistently.

## Do's and Don'ts

### Do

- **DO** validate JWT tokens on all protected endpoints using Azure AD public keys.
- **DO** use middleware to handle authentication consistently across all protected routes.
- **DO** extract and validate user claims (roles, permissions) from tokens.
- **DO** implement role-based authorization checks before executing business logic.
- **DO** return appropriate HTTP status codes (401 for unauthorized, 403 for forbidden).
- **DO** log authentication and authorization failures for security monitoring.
- **DO** verify token audience (aud) and issuer (iss) claims match your application.
- **DO** handle token expiration gracefully with clear error messages.
- **DO** use environment variables for Azure AD configuration (tenant ID, client ID, etc.).
- **DO** implement a clear separation between public endpoints (no auth required) and protected endpoints.

### Don't

- **DON'T** skip token validation on any endpoint that requires authentication.
- **DON'T** trust claims from tokens without validating the token signature first.
- **DON'T** implement custom JWT validation. Use established libraries.
- **DON'T** store tokens in the backend. They should be sent with each request.
- **DON'T** hardcode Azure AD configuration values.
- **DON'T** return detailed error messages about authentication failures to clients (security risk).
- **DON'T** use the same endpoint for both authenticated and unauthenticated access.
- **DON'T** bypass authorization checks in development environments.
- **DON'T** assume a valid token means the user has permission for all operations.

## Consequences

### Positive

- **Security:** Proper token validation prevents unauthorized access to backend resources.
- **Stateless:** No session management required on the backend, improving scalability.
- **Integration:** Seamless integration with frontend Azure AD authentication ([ADR-022](./ADR-022.md)).
- **Role-Based Access:** Fine-grained authorization based on user roles and claims.
- **Compliance:** Meets enterprise security requirements and audit needs.
- **Consistency:** Standardized authentication across all Dasolve backends.
- **Monitoring:** Centralized logging of authentication events for security analysis.

### Negative

- **Complexity:** JWT validation and claims processing add complexity to backend code.
- **Performance:** Token validation on every request adds overhead (though minimal with proper caching).
- **Configuration:** Requires proper Azure AD app registration and configuration.
- **Learning Curve:** Developers must understand JWT, Azure AD tokens, and RBAC concepts.

### Risks

- **Token Replay Attacks:** Stolen tokens could be reused. This will be mitigated by:
  - Using short-lived tokens with automatic refresh on the frontend
  - Implementing token expiration checks
  - Monitoring for suspicious patterns in token usage
- **Configuration Errors:** Incorrect Azure AD configuration can break authentication. This will be mitigated by:
  - Providing clear documentation and examples
  - Validating configuration at application startup
  - Using environment-specific configuration files
- **Key Rotation:** Azure AD periodically rotates signing keys. This will be mitigated by:
  - Using libraries that automatically fetch and cache Azure AD public keys
  - Implementing proper error handling for key validation failures

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve backend scaffolding will include Azure AD authentication middleware pre-configured.
- **Environment Configuration:** Azure AD configuration will be managed via environment variables:
  ```typescript
  const azureAdConfig = {
    tenantId: process.env.AZURE_AD_TENANT_ID!,
    clientId: process.env.AZURE_AD_CLIENT_ID!,
    audience: process.env.AZURE_AD_AUDIENCE!,
  };
  ```
- **Code Reviews:** Reviewers must ensure:
  - All protected endpoints use authentication middleware
  - Token validation is implemented correctly
  - Authorization checks are performed based on roles/claims
  - Error handling is secure and doesn't leak sensitive information
  - Public endpoints are intentionally marked as such

### Standard Implementation

Example authentication middleware using `hono-middleware-jwt`:

```typescript
import { Hono } from "hono";
import { jwt } from "hono/jwt";
import { HTTPException } from "hono/http-exception";

const app = new Hono();

// Azure AD configuration
const azureAdConfig = {
  tenantId: process.env.AZURE_AD_TENANT_ID!,
  clientId: process.env.AZURE_AD_CLIENT_ID!,
  audience: process.env.AZURE_AD_AUDIENCE!,
};

const jwksUri = `https://login.microsoftonline.com/${azureAdConfig.tenantId}/discovery/v2.0/keys`;

// Authentication middleware
const authMiddleware = jwt({
  jwksUri,
  audience: azureAdConfig.audience,
  issuer: `https://login.microsoftonline.com/${azureAdConfig.tenantId}/v2.0`,
});

// Public endpoint - no authentication required
app.get("/api/health", (c) => {
  return c.json({ status: "healthy" });
});

// Protected endpoint - authentication required
app.get("/api/user/profile", authMiddleware, async (c) => {
  const payload = c.get("jwtPayload");
  const userId = payload.sub; // User ID from token

  const profile = await getUserProfile(userId);
  return c.json(profile);
});

// Protected endpoint with role check
app.post("/api/admin/users", authMiddleware, async (c) => {
  const payload = c.get("jwtPayload");
  const roles = payload.roles || [];

  // Check if user has admin role
  if (!roles.includes("Admin")) {
    throw new HTTPException(403, {
      message: "Insufficient permissions",
    });
  }

  const body = await c.req.json();
  const newUser = await createUser(body);
  return c.json(newUser, 201);
});
```

Example role-based authorization helper:

```typescript
import { Context } from "hono";
import { HTTPException } from "hono/http-exception";

interface JwtPayload {
  sub: string;
  roles?: string[];
  email?: string;
  name?: string;
}

export function requireRole(...allowedRoles: string[]) {
  return async (c: Context, next: () => Promise<void>) => {
    const payload = c.get("jwtPayload") as JwtPayload;
    const userRoles = payload.roles || [];

    const hasRequiredRole = allowedRoles.some((role) =>
      userRoles.includes(role)
    );

    if (!hasRequiredRole) {
      throw new HTTPException(403, {
        message: "Insufficient permissions",
      });
    }

    await next();
  };
}

// Usage
app.delete(
  "/api/users/:id",
  authMiddleware,
  requireRole("Admin", "UserManager"),
  async (c) => {
    const userId = c.req.param("id");
    await deleteUser(userId);
    return c.json({ success: true });
  }
);
```

Example extracting user information from token:

```typescript
import { Context } from "hono";

interface UserContext {
  userId: string;
  email: string;
  name: string;
  roles: string[];
}

export function getUserFromToken(c: Context): UserContext {
  const payload = c.get("jwtPayload");

  return {
    userId: payload.sub,
    email: payload.email || "",
    name: payload.name || "",
    roles: payload.roles || [],
  };
}

// Usage in route handler
app.get("/api/dashboard", authMiddleware, async (c) => {
  const user = getUserFromToken(c);

  const dashboardData = await getDashboardData(user.userId);
  return c.json(dashboardData);
});
```

Example custom claims validation:

```typescript
import { Context } from "hono";
import { HTTPException } from "hono/http-exception";

export function requireClaim(claimName: string, allowedValues: string[]) {
  return async (c: Context, next: () => Promise<void>) => {
    const payload = c.get("jwtPayload");
    const claimValue = payload[claimName];

    if (!claimValue || !allowedValues.includes(claimValue)) {
      throw new HTTPException(403, {
        message: `Required claim '${claimName}' not found or invalid`,
      });
    }

    await next();
  };
}

// Usage - require specific department claim
app.get(
  "/api/department/finance",
  authMiddleware,
  requireClaim("department", ["Finance", "Accounting"]),
  async (c) => {
    const data = await getFinanceData();
    return c.json(data);
  }
);
```

Example error handling for authentication:

```typescript
import { Hono } from "hono";
import { HTTPException } from "hono/http-exception";

const app = new Hono();

// Global error handler
app.onError((err, c) => {
  if (err instanceof HTTPException) {
    // Return appropriate status code with generic message
    return c.json(
      {
        error: err.message,
      },
      err.status
    );
  }

  // Log detailed error server-side
  console.error("Authentication error:", err);

  // Return generic error to client
  return c.json(
    {
      error: "Authentication failed",
    },
    401
  );
});

app.use("*", async (c, next) => {
  try {
    await next();
  } catch (error) {
    // Log authentication failures for security monitoring
    if (error instanceof HTTPException && error.status === 401) {
      console.warn("Authentication failure:", {
        path: c.req.path,
        method: c.req.method,
        timestamp: new Date().toISOString(),
        error: error.message,
      });
    }
    throw error;
  }
});
```

### Testing Considerations

When testing protected endpoints:

```typescript
import { describe, it, expect } from "bun:test";
import { app } from "./app";

describe("Protected endpoints", () => {
  it("should reject requests without token", async () => {
    const res = await app.request("/api/user/profile");
    expect(res.status).toBe(401);
  });

  it("should reject requests with invalid token", async () => {
    const res = await app.request("/api/user/profile", {
      headers: {
        Authorization: "Bearer invalid-token",
      },
    });
    expect(res.status).toBe(401);
  });

  it("should accept requests with valid token", async () => {
    // In tests, use a test JWT token or mock the JWT middleware
    const validToken = generateTestToken({
      sub: "user-123",
      roles: ["User"],
    });

    const res = await app.request("/api/user/profile", {
      headers: {
        Authorization: `Bearer ${validToken}`,
      },
    });
    expect(res.status).toBe(200);
  });

  it("should reject requests without required role", async () => {
    const userToken = generateTestToken({
      sub: "user-123",
      roles: ["User"],
    });

    const res = await app.request("/api/admin/users", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${userToken}`,
      },
      body: JSON.stringify({ name: "New User" }),
    });
    expect(res.status).toBe(403);
  });
});
```

### Exceptions

- Public APIs that don't require authentication (health checks, public documentation) should not use authentication middleware.
- Internal service-to-service communication may use different authentication mechanisms (API keys, service principals).
- Alternative authentication providers may be used if explicitly required by the business, but must provide equivalent security guarantees.
- Other exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-022: Azure AD Authentication Support (Frontend)](./ADR-022.md)
- [ADR-030: Backend for Frontend (BFF) Architecture](./ADR-030.md)
- [ADR-031: Hono Backend Framework](./ADR-031.md)
- [Azure AD Token Validation](https://docs.microsoft.com/en-us/azure/active-directory/develop/access-tokens)
- [JWT Best Practices](https://datatracker.ietf.org/doc/html/rfc8725)
- [Hono JWT Middleware](https://hono.dev/middleware/builtin/jwt)
- [OWASP API Security Top 10](https://owasp.org/www-project-api-security/)
