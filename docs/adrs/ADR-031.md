# ADR-031: Hono as the Backend Framework

## Context

Building backends for enterprise data-driven applications requires a framework that balances performance, developer experience, and type safety. Following the Backend for Frontend (BFF) architecture ([ADR-030](./ADR-030.md)), Dasolve backends need to:

- **Serve Specific Frontend Needs:** Create endpoints optimized for the frontend's exact data requirements
- **End-to-End Type Safety:** Enable seamless type sharing between frontend and backend ([ADR-025](./ADR-025.md))
- **High Performance:** Handle data aggregation from multiple sources efficiently
- **Developer Experience:** Provide an intuitive API that's easy to learn and use
- **TypeScript First:** Integrate seamlessly with TypeScript ([ADR-001](./ADR-001.md))
- **Runtime Flexibility:** Support modern runtimes like Bun ([ADR-005](./ADR-005.md)) and Node.js ([ADR-006](./ADR-006.md))
- **Edge Deployment Ready:** Enable deployment to edge environments when needed

Traditional Node.js frameworks present challenges:

- **Express.js:** While mature and widely used, it lacks native TypeScript support, has dated APIs, and requires extensive middleware configuration for modern features. Type safety requires significant boilerplate with libraries like `express-validator`.
- **Fastify:** Better performance than Express but still requires substantial configuration for TypeScript and type-safe routing. Middleware ecosystem is smaller.
- **NestJS:** Excellent TypeScript support but heavyweight with Angular-inspired architecture that adds unnecessary complexity for BFF patterns. The decorator-heavy approach and dependency injection create excessive boilerplate.
- **Koa:** Minimal and modern but lacks built-in routing and type safety features, requiring extensive setup.

For **enterprise applications** built on the Dasolve framework:

- **Rapid Development:** Teams need to build BFF endpoints quickly without fighting the framework
- **Type Safety:** Frontend and backend types must stay synchronized without manual effort
- **Lightweight:** Small bundle sizes and minimal overhead for optimal performance
- **Modern JavaScript:** Native support for async/await, ESM, and modern JavaScript features
- **Edge Compatible:** Ability to deploy to edge environments (Cloudflare Workers, Vercel Edge, etc.) when beneficial

The framework choice directly impacts development velocity, application performance, and maintenance burden.

## Decision

All **backends built on the Dasolve framework** must use **Hono** as the backend framework.

Hono will be used with:

- **TypeScript** ([ADR-001](./ADR-001.md)) for all backend code
- **Bun** ([ADR-005](./ADR-005.md)) as the primary runtime
- **Hono RPC** (ADR-032) for end-to-end type safety with the frontend
- **Zod Validator Middleware** (ADR-032) for request validation

Hono provides:

- Ultra-lightweight framework (< 20KB) with minimal overhead
- First-class TypeScript support with excellent type inference
- Simple, intuitive API similar to Express but modern
- Built-in support for multiple runtimes (Bun, Node.js, Deno, edge)
- Hono RPC for seamless frontend-backend type safety
- Excellent performance (faster than Express and Fastify)
- Middleware ecosystem with essential features (CORS, authentication, rate limiting, etc.)

This decision ensures Dasolve backends are performant, maintainable, and provide excellent developer experience while enabling end-to-end type safety.

## Do's and Don'ts

### Do

- **DO** use Hono's context API (`c`) to access request data, set responses, and manage middleware state.
- **DO** leverage Hono's middleware system for cross-cutting concerns (authentication, CORS, rate limiting, logging).
- **DO** use Hono RPC (ADR-032) to create type-safe endpoints that the frontend can call with full IntelliSense.
- **DO** validate request inputs with Zod Validator Middleware (ADR-032) for body, query, and path parameters.
- **DO** structure routes logically by grouping related endpoints (e.g., `/api/users`, `/api/products`).
- **DO** use Hono's built-in helpers like `c.json()`, `c.text()`, `c.redirect()` for responses.
- **DO** implement proper error handling with try-catch blocks and error middleware.
- **DO** use async/await for all asynchronous operations (database queries, external API calls, etc.).
- **DO** leverage Hono's chaining API for clean, readable route definitions.
- **DO** use environment variables for configuration (database URLs, API keys, etc.).

### Don't

- **DON'T** use other backend frameworks (Express, Fastify, NestJS, Koa) for Dasolve projects.
- **DON'T** create unnecessary abstraction layers over Hono. Keep the architecture simple and use Hono's APIs directly.
- **DON'T** use callback-based patterns. Always use async/await with Hono.
- **DON'T** bypass Hono's middleware system. Use middleware for cross-cutting concerns rather than duplicating logic in routes.
- **DON'T** ignore request validation. Always validate inputs with Zod Validator Middleware.
- **DON'T** return raw errors to clients. Use proper error handling middleware to format error responses.
- **DON'T** block the event loop with CPU-intensive synchronous operations. Offload heavy processing to background jobs.
- **DON'T** create overly generic middleware that tries to handle every use case. Keep middleware focused and composable.

## Consequences

### Positive

- **Excellent Type Safety:** Hono's TypeScript support and RPC capabilities enable full type safety from frontend to backend with minimal boilerplate.
- **Outstanding Performance:** Hono is one of the fastest Node.js/Bun frameworks, handling requests with minimal overhead.
- **Small Bundle Size:** Hono's tiny footprint (< 20KB) reduces cold start times and deployment sizes.
- **Developer Experience:** Simple, intuitive API that's easy to learn and use. Developers familiar with Express can be productive immediately.
- **Runtime Flexibility:** Works seamlessly with Bun, Node.js, Deno, and edge runtimes without code changes.
- **Edge Deployment Ready:** Native support for Cloudflare Workers, Vercel Edge, and other edge platforms when needed.
- **Active Development:** Hono is actively maintained with frequent updates and a growing community.
- **Minimal Boilerplate:** Less configuration and setup compared to heavier frameworks like NestJS.
- **Middleware Ecosystem:** Built-in middleware for common needs (CORS, JWT, rate limiting, etc.) with easy extensibility.
- **BFF-Friendly:** Lightweight and flexible architecture aligns perfectly with BFF patterns ([ADR-030](./ADR-030.md)).

### Negative

- **Smaller Ecosystem:** Compared to Express, Hono has fewer third-party middleware and plugins (though the core middleware covers most needs).
- **Newer Framework:** Less battle-tested than Express in large-scale enterprise applications (though Hono is production-ready and used by major companies).
- **Learning Curve for Teams:** Teams accustomed to Express or NestJS will need to learn Hono's patterns and best practices.
- **Less Stack Overflow Content:** Fewer existing answers and tutorials compared to more established frameworks.

### Risks

- **Framework Maturity:** As a newer framework, Hono may have undiscovered edge cases or bugs. This will be mitigated by:
  - Comprehensive testing at application level
  - Active monitoring of Hono's GitHub issues
  - Contributing bug reports and fixes back to the project
  - Regular framework updates to benefit from community improvements
- **Breaking Changes:** Major Hono updates might introduce breaking changes. This will be mitigated by:
  - Maintaining a conservative update policy
  - Testing updates thoroughly in staging environments
  - Following Hono's migration guides for major versions
  - Documenting any required migration steps
- **Dependency on Bun:** While Hono supports multiple runtimes, the primary Dasolve stack uses Bun ([ADR-005](./ADR-005.md)). If Bun development slows, Hono's Node.js compatibility provides a fallback.

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve backend scaffolding will include Hono configured with TypeScript and Bun.
- **Package Dependencies:** `package.json` files must include Hono as the core backend dependency.
- **Build Configuration:** Bun ([ADR-005](./ADR-005.md)) will be configured for optimal performance with Hono.
- **Code Reviews:** Reviewers must ensure:
  - Endpoints follow BFF patterns ([ADR-030](./ADR-030.md)), not generic CRUD
  - Request validation using Zod Validator Middleware (ADR-032)
  - Proper error handling with error middleware
  - Hono RPC used for type-safe frontend communication (ADR-032)
  - Appropriate middleware usage for cross-cutting concerns
- **ESLint Rules:** Standard TypeScript linting ([ADR-011](./ADR-011.md)) will catch common mistakes.
- **Testing Requirements:** All endpoints must have integration tests covering success and error cases.

### Standard Implementation

Basic Hono setup for a BFF backend:

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";
import { logger } from "hono/logger";

const app = new Hono();

// Middleware
app.use("*", logger());
app.use(
  "*",
  cors({
    origin: ["http://localhost:5173"], // Frontend dev server
    credentials: true,
  })
);

// Health check endpoint
app.get("/health", (c) => {
  return c.json({ status: "healthy" });
});

// BFF endpoint optimized for dashboard view
app.get("/api/dashboard", async (c) => {
  const userId = c.req.query("userId");

  try {
    // Aggregate data from multiple sources
    const [user, recentActivity, stats] = await Promise.all([
      getUserById(userId),
      getRecentActivity(userId, 10),
      getUserStats(userId),
    ]);

    // Return data shaped for the UI
    return c.json({
      user: {
        name: user.fullName,
        email: user.email,
        avatar: user.avatarUrl,
      },
      activity: recentActivity.map((item) => ({
        id: item.id,
        type: item.activityType,
        description: item.description,
        timestamp: item.createdAt,
      })),
      stats: {
        totalActions: stats.actionCount,
        lastLoginAt: stats.lastLogin,
        memberSince: user.createdAt,
      },
    });
  } catch (error) {
    console.error("Dashboard error:", error);
    return c.json({ error: "Failed to load dashboard" }, 500);
  }
});

export default app;

// For Bun runtime
export default {
  port: 3000,
  fetch: app.fetch,
};
```

Using middleware for authentication:

```typescript
import { Hono } from "hono";
import { jwt } from "hono/jwt";

const app = new Hono();

// JWT middleware for protected routes
const jwtMiddleware = jwt({
  secret: process.env.JWT_SECRET!,
});

// Public endpoint
app.get("/api/public", (c) => {
  return c.json({ message: "Public data" });
});

// Protected endpoint
app.get("/api/protected", jwtMiddleware, async (c) => {
  // JWT payload is available in c.get("jwtPayload")
  const payload = c.get("jwtPayload");

  return c.json({
    message: "Protected data",
    userId: payload.sub,
  });
});

// Protected routes group
const api = new Hono();

api.use("*", jwtMiddleware);

api.get("/users/:id", async (c) => {
  const id = c.req.param("id");
  const user = await getUserById(id);
  return c.json(user);
});

api.post("/orders", async (c) => {
  const body = await c.req.json();
  const order = await createOrder(body);
  return c.json(order, 201);
});

app.route("/api", api);
```

Error handling with middleware:

```typescript
import { Hono } from "hono";

const app = new Hono();

// Custom error class
class AppError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
    public code?: string
  ) {
    super(message);
    this.name = "AppError";
  }
}

// Error handling middleware
app.onError((err, c) => {
  console.error("Error:", err);

  if (err instanceof AppError) {
    return c.json(
      {
        error: err.message,
        code: err.code,
      },
      err.statusCode
    );
  }

  // Unknown errors
  return c.json(
    {
      error: "Internal server error",
    },
    500
  );
});

// Route that may throw errors
app.get("/api/user/:id", async (c) => {
  const id = c.req.param("id");

  const user = await getUserById(id);

  if (!user) {
    throw new AppError("User not found", 404, "USER_NOT_FOUND");
  }

  return c.json(user);
});
```

Composing multiple data sources (BFF pattern):

```typescript
import { Hono } from "hono";

const app = new Hono();

// BFF endpoint aggregating multiple data sources
app.get("/api/product/:id/complete", async (c) => {
  const productId = c.req.param("id");

  try {
    // Fetch from multiple sources in parallel
    const [product, inventory, reviews, recommendations] = await Promise.all([
      db.products.findById(productId),
      inventoryService.getStock(productId),
      reviewsAPI.getProductReviews(productId),
      recommendationEngine.getSimilar(productId, 5),
    ]);

    if (!product) {
      return c.json({ error: "Product not found" }, 404);
    }

    // Return composed data shaped for the UI
    return c.json({
      product: {
        id: product.id,
        name: product.name,
        description: product.description,
        price: product.price,
        images: product.images,
      },
      inventory: {
        inStock: inventory.quantity > 0,
        quantity: inventory.quantity,
        warehouse: inventory.location,
        estimatedDelivery: calculateDeliveryDate(inventory),
      },
      reviews: {
        averageRating: reviews.average,
        totalCount: reviews.count,
        recent: reviews.items.slice(0, 3).map((r) => ({
          author: r.userName,
          rating: r.stars,
          comment: r.comment,
          date: r.createdAt,
          verified: r.verifiedPurchase,
        })),
      },
      recommendations: recommendations.map((p) => ({
        id: p.id,
        name: p.name,
        image: p.thumbnailUrl,
        price: p.price,
      })),
    });
  } catch (error) {
    console.error("Product fetch error:", error);
    return c.json({ error: "Failed to load product details" }, 500);
  }
});
```

### Exceptions

- Projects requiring integration with existing Express-based infrastructure may continue using Express for that specific integration layer, but the main BFF backend must use Hono.
- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-001: Primary Programming Language (TypeScript)](./ADR-001.md)
- [ADR-005: Bun as Primary Runtime](./ADR-005.md)
- [ADR-006: Node.js for Bun-Incompatible Tools](./ADR-006.md)
- [ADR-025: End-to-End Type Safety](./ADR-025.md)
- [ADR-030: Backend for Frontend Architecture](./ADR-030.md)
- ADR-032: Hono RPC and Zod Validation (to be written)
- ADR-033: CORS Support (to be written)
- [Hono Official Documentation](https://hono.dev/)
- [Hono GitHub Repository](https://github.com/honojs/hono)
- [Hono RPC Documentation](https://hono.dev/docs/guides/rpc)
