# ADR-023: Storybook for Component Development and Testing

## Context

Developing UI components in isolation provides significant benefits:

- **Faster iteration** without running the full application
- **Better testing** of component variations and edge cases
- **Living documentation** of components with interactive examples
- **Visual regression testing** to catch UI bugs
- **Component catalog** for discovering and reusing components
- **Design system enforcement** ensuring consistency

Without a component development tool, developers would:

- Need to run the full application to see component changes
- Manually navigate to specific routes to test components
- Struggle to test all component states and variations
- Lack documentation of component usage
- Duplicate components unknowingly
- Create inconsistent component patterns

For **enterprise applications**, isolated component development is essential for:

- **Building design systems** with reusable components
- **Collaborative development** where designers and developers review components
- **Quality assurance** through visual testing of all component states
- **Onboarding** new developers with interactive component documentation

Storybook has emerged as the industry-standard tool for component development, with widespread adoption and extensive ecosystem support.

## Decision

All **frontends built on the Dasolve framework** must use **Storybook** (version 8 or later) for developing and testing frontend components in isolation.

Storybook will be configured with:

- **Component stories** for both presentational and connected components
- **MSW (Mock Service Worker) integration** for mocking API calls in connected component stories
- **Controls/args** for interactive component property testing
- **Multiple states/variants** per component (loading, error, empty, etc.)
- **Accessibility testing** with the a11y addon
- **Vite integration** for fast refresh and build performance

### Component Development Workflow

1. Create component in isolation
2. Write Storybook stories covering all states and variations
3. Test interactively in Storybook
4. Review with team (designers, developers, QA)
5. Integrate into application once approved

This decision ensures consistent component quality, comprehensive documentation, and efficient development workflow.

## Do's and Don'ts

### Do

- **DO** create Storybook stories for all components (presentational, connected, and page components).
- **DO** test all component variations (different props, states, sizes).
- **DO** create stories for the four core states: **default, empty, loading, and error**. Every component must have at minimum these four states tested.
- **DO** use MSW (Mock Service Worker) to intercept and mock API calls in connected component and page component stories.
- **DO** use Storybook controls/args to make components interactive.
- **DO** write documentation in MDX format for complex components.
- **DO** use the accessibility (a11y) addon to test WCAG compliance.
- **DO** organize stories with logical naming and grouping.
- **DO** run Storybook during development for quick feedback.

### Don't

- **DON'T** skip writing stories for reusable components.
- **DON'T** make real API calls in stories. Always use MSW to mock backend responses.
- **DON'T** test only the happy path. Include error and edge case stories.
- **DON'T** ignore accessibility warnings from the a11y addon.
- **DON'T** commit broken stories that fail to render.
- **DON'T** use Storybook as a replacement for proper unit/integration tests.

## Consequences

### Positive

- **Isolated Development:** Develop components without running the full application, speeding up iteration.
- **Living Documentation:** Stories serve as interactive documentation for component usage.
- **Visual Testing:** Easily test all component states and variations visually.
- **Design System:** Build and maintain a cohesive design system with component catalog.
- **Collaboration:** Designers, developers, and QA can review components before integration.
- **Accessibility:** Built-in a11y testing helps ensure WCAG compliance.
- **Quality:** Comprehensive story coverage catches edge cases before production.
- **Developer Experience:** Fast refresh with Vite makes component development efficient.

### Negative

- **Setup Overhead:** Requires initial configuration and learning curve, including MSW setup.
- **Maintenance:** Stories need to be updated when components change, including MSW mocks.
- **Build Time:** Adds another build target to the project.
- **MSW Complexity:** Mocking API responses adds complexity for connected component stories.

### Risks

- **Story Drift:** Stories might become outdated as components evolve. This will be mitigated by:
  - Including story maintenance in code review process
  - Treating story failures as build failures in CI/CD
  - Regular story audits during sprint reviews
- **Overuse:** Developers might create stories for every component including simple ones. This will be mitigated by:
  - Clear guidelines on when stories are required
  - Focusing on reusable presentational components
  - Code review enforcement

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve frontend scaffolding will include Storybook pre-configured with:
  - Storybook 8+ with Vite builder
  - Essential addons (a11y, controls, docs, interactions, MSW)
  - Example stories demonstrating best practices for both presentational and connected components
  - TypeScript configuration
  - MSW (Mock Service Worker) integration
- **Storybook Configuration:** Standard `.storybook/main.ts`:

  ```typescript
  import type { StorybookConfig } from "@storybook/react-vite";

  const config: StorybookConfig = {
    stories: ["../src/**/*.mdx", "../src/**/*.stories.@(js|jsx|ts|tsx)"],
    addons: [
      "@storybook/addon-links",
      "@storybook/addon-essentials",
      "@storybook/addon-interactions",
      "@storybook/addon-a11y",
    ],
    framework: {
      name: "@storybook/react-vite",
      options: {},
    },
    staticDirs: ["../public"],
  };

  export default config;
  ```

- **MSW Setup:** Configure MSW in `.storybook/preview.ts`:

  ```typescript
  import { initialize, mswLoader } from "msw-storybook-addon";

  // Initialize MSW
  initialize();

  const preview = {
    parameters: {
      controls: {
        matchers: {
          color: /(background|color)$/i,
          date: /Date$/i,
        },
      },
    },
    loaders: [mswLoader],
  };

  export default preview;
  ```

- **Code Reviews:** Reviewers must ensure:
  - Stories exist for reusable components (both presentational and connected)
  - Stories cover all four core states (default, empty, loading, error)
  - MSW handlers are used for connected component stories (no real API calls)
  - Accessibility addon shows no critical violations
  - Stories render without errors
- **CI/CD:** Storybook build will be part of CI pipeline to catch story failures early.

### Standard Story Example

Example component (`UserCard.tsx`):

```typescript
import { Card, CardContent, Avatar, Typography } from "@mui/material";

export interface UserCardProps {
  name: string;
  email: string;
  avatarUrl?: string;
  role: "admin" | "user" | "guest";
  loading?: boolean;
}

export function UserCard({
  name,
  email,
  avatarUrl,
  role,
  loading = false,
}: UserCardProps) {
  if (loading) {
    return <Card>Loading...</Card>;
  }

  return (
    <Card>
      <CardContent>
        <Avatar src={avatarUrl}>{name.charAt(0)}</Avatar>
        <Typography variant="h6">{name}</Typography>
        <Typography variant="body2" color="text.secondary">
          {email}
        </Typography>
        <Typography variant="caption">{role}</Typography>
      </CardContent>
    </Card>
  );
}
```

Example story (`UserCard.stories.tsx`):

```typescript
import type { Meta, StoryObj } from "@storybook/react";
import { UserCard } from "./UserCard";

const meta = {
  title: "Components/UserCard",
  component: UserCard,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    role: {
      control: "select",
      options: ["admin", "user", "guest"],
    },
  },
} satisfies Meta<typeof UserCard>;

export default meta;
type Story = StoryObj<typeof meta>;

// ========================================
// CORE STATES (Required for all components)
// ========================================

// 1. Default state
export const Default: Story = {
  args: {
    name: "John Doe",
    email: "john.doe@example.com",
    role: "user",
    avatarUrl: "https://i.pravatar.cc/150?img=1",
  },
};

// 2. Empty state
export const Empty: Story = {
  args: {
    name: "",
    email: "",
    role: "guest",
  },
};

// 3. Loading state
export const Loading: Story = {
  args: {
    name: "John Doe",
    email: "john.doe@example.com",
    role: "user",
    loading: true,
  },
};

// 4. Error state
export const Error: Story = {
  args: {
    name: "John Doe",
    email: "john.doe@example.com",
    role: "user",
    error: "Failed to load user data",
  },
};

// ========================================
// Additional variations (optional)
// ========================================

// Admin user variation
export const Admin: Story = {
  args: {
    name: "Jane Smith",
    email: "jane.smith@example.com",
    role: "admin",
    avatarUrl: "https://i.pravatar.cc/150?img=2",
  },
};

// Edge case: Long name
export const LongName: Story = {
  args: {
    name: "Christopher Alexander Maximilian Thompson",
    email: "christopher.thompson@example.com",
    role: "user",
  },
};
```

### Connected Component Story Example with MSW

Example connected component (`UserListConnected.tsx`):

```typescript
import { useQuery } from "@tanstack/react-query";
import { apiClient } from "../api/client";

export function UserListConnected() {
  const {
    data: users,
    isLoading,
    error,
  } = useQuery({
    queryKey: ["users"],
    queryFn: async () => {
      const response = await apiClient.users.$get();
      return response.json();
    },
  });

  if (isLoading) return <div>Loading users...</div>;
  if (error) return <div>Error loading users: {error.message}</div>;
  if (!users || users.length === 0) return <div>No users found</div>;

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>
          {user.name} - {user.email}
        </li>
      ))}
    </ul>
  );
}
```

Example connected component story with MSW (`UserListConnected.stories.tsx`):

```typescript
import type { Meta, StoryObj } from "@storybook/react";
import { http, HttpResponse, delay } from "msw";
import { UserListConnected } from "./UserListConnected";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const meta = {
  title: "Components/UserListConnected",
  component: UserListConnected,
  decorators: [
    (Story) => (
      <QueryClientProvider client={new QueryClient()}>
        <Story />
      </QueryClientProvider>
    ),
  ],
} satisfies Meta<typeof UserListConnected>;

export default meta;
type Story = StoryObj<typeof meta>;

// ========================================
// CORE STATES (Required for all components)
// ========================================

// 1. Default state - successful API response
export const Default: Story = {
  parameters: {
    msw: {
      handlers: [
        http.get("/api/users", () => {
          return HttpResponse.json([
            { id: "1", name: "John Doe", email: "john@example.com" },
            { id: "2", name: "Jane Smith", email: "jane@example.com" },
          ]);
        }),
      ],
    },
  },
};

// 2. Empty state - no users
export const Empty: Story = {
  parameters: {
    msw: {
      handlers: [
        http.get("/api/users", () => {
          return HttpResponse.json([]);
        }),
      ],
    },
  },
};

// 3. Loading state
export const Loading: Story = {
  parameters: {
    msw: {
      handlers: [
        http.get("/api/users", async () => {
          await delay("infinite");
        }),
      ],
    },
  },
};

// 4. Error state - API error
export const Error: Story = {
  parameters: {
    msw: {
      handlers: [
        http.get("/api/users", () => {
          return HttpResponse.json(
            { message: "Internal server error" },
            { status: 500 }
          );
        }),
      ],
    },
  },
};
```

### Story Organization

Stories should be organized to match component hierarchy:

```
src/
├── components/
│   ├── UserCard/
│   │   ├── UserCard.tsx
│   │   ├── UserCard.stories.tsx
│   │   └── UserCard.module.css
│   └── Dashboard/
│       ├── Dashboard.tsx
│       └── DashboardWidgets/
│           ├── MetricWidget.tsx
│           └── MetricWidget.stories.tsx
├── pages/
│   ├── HomePage.tsx
│   ├── HomePage.stories.tsx
│   ├── UserDetailPage.tsx
│   └── UserDetailPage.stories.tsx
```

### Exceptions

- **Subcomponents** of larger presentational components (e.g., table rows, table cells, accordion items) may not require their own separate story files. However, their code **must be covered** within the parent component's stories by demonstrating all variations and states of the subcomponents.
- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-015: React.JS Framework](ADR-015.md)
- [ADR-024: Separation of Stateful and Stateless Components](ADR-024.md)
- [Storybook Official Documentation](https://storybook.js.org/)
- [Storybook for React](https://storybook.js.org/docs/react/get-started/introduction)
- [Storybook Accessibility Addon](https://storybook.js.org/addons/@storybook/addon-a11y)
