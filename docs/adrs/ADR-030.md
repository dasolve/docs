# ADR-030: Backend for Frontend (BFF) Architecture

## Context

Enterprise data-driven applications require backends that efficiently serve their frontend clients. Traditional backend architectures present several challenges:

- **Generic REST APIs:** Backends designed to serve multiple clients (web, mobile, IoT, etc.) create overly generic endpoints that don't optimize for any specific client's needs
- **Data Over-fetching/Under-fetching:** Clients receive too much data (requiring filtering client-side) or too little (requiring multiple round trips)
- **Client-Side Data Wrangling:** Frontends must combine, transform, and reshape data from multiple endpoints, violating [ADR-026](./ADR-026.md)
- **Impedance Mismatch:** Backend data structures often don't match frontend UI needs, forcing complex transformations
- **Slow Iteration:** Changes require coordinating across multiple client teams to ensure backward compatibility

For **enterprise applications** built on the Dasolve framework:

- **Single Responsive Frontend:** One SPA that works across all devices (desktop, tablet, mobile) per [ADR-015](./ADR-015.md)
- **Complex Data Requirements:** Applications involve data aggregation from multiple sources (databases, external APIs, data jobs)
- **Performance Critical:** Long-running sessions ([ADR-015](./ADR-015.md)) require optimal data fetching with minimal overhead
- **Type Safety:** End-to-end type safety ([ADR-025](./ADR-025.md)) demands tight frontend-backend coupling
- **Rapid Development:** Teams need to iterate quickly without backward compatibility constraints from serving multiple clients

The Backend for Frontend (BFF) pattern addresses these challenges by creating a backend specifically optimized for the needs of a single frontend client.

## Decision

All **backends built on the Dasolve framework** must follow the **Backend for Frontend (BFF)** architecture pattern.

In this architecture:

- Each Dasolve solution has **one responsive frontend** and **one backend** dedicated to serving it
- The backend is **tightly coupled** to the frontend's data requirements
- The backend acts as an **aggregation and orchestration layer** that:
  - Fetches data from multiple sources (databases, external APIs, microservices, machine learning functions, etc.)
  - Composes and transforms data into the exact shape the UI needs
  - Handles business logic that shouldn't live in the frontend
  - Provides optimized endpoints matching frontend use cases
- The backend **does not aim to be generic** or serve hypothetical future clients
- Breaking changes are **acceptable and expected** since there's only one consumer

This tight coupling is intentional and beneficial—it enables:

- End-to-end type safety with Hono RPC ([ADR-025](./ADR-025.md), [ADR-032](./ADR-032.md))
- Frontend staying lean without data wrangling ([ADR-026](./ADR-026.md))
- Rapid iteration without backward compatibility concerns
- APIs designed for actual UI needs, not generic CRUD operations

## Do's and Don'ts

### Do

- **DO** design backend endpoints specifically for the frontend's UI needs, not as generic REST resources.
- **DO** aggregate data from multiple sources in the backend before returning it to the frontend.
- **DO** transform and shape data server-side to match exactly what the UI requires.
- **DO** handle complex business logic in the backend, keeping the frontend lean.
- **DO** iterate quickly on the backend, making breaking changes when they improve the API.
- **DO** optimize endpoints for specific use cases (e.g., a `/dashboard` endpoint that returns all dashboard data in one call).
- **DO** treat the backend and frontend as a single logical unit that evolves together.
- **DO** use the monorepo structure ([ADR-013](./ADR-013.md)) to keep backend and frontend in sync.

### Don't

- **DON'T** design generic REST APIs trying to serve hypothetical future clients (mobile apps, third-party integrations, etc.).
- **DON'T** force the frontend to make multiple API calls to assemble data for a single view.
- **DON'T** return raw database entities to the frontend. Transform data into UI-specific shapes.
- **DON'T** maintain backward compatibility for old API versions when you can coordinate frontend changes.
- **DON'T** put data aggregation or transformation logic in the frontend ([ADR-026](./ADR-026.md)).
- **DON'T** create separate backends for different device types (mobile, tablet, desktop). Use one responsive frontend ([ADR-015](./ADR-015.md)) with one backend.
- **DON'T** treat the backend as a separate service with its own independent lifecycle. It exists to serve the frontend.

## Consequences

### Positive

- **Optimal Data Fetching:** Frontend receives exactly the data it needs in the exact shape it needs, minimizing over-fetching and under-fetching.
- **Frontend Stays Lean:** All data aggregation, transformation, and composition happens server-side per [ADR-026](./ADR-026.md).
- **Perfect Type Safety:** Tight coupling enables end-to-end type safety with Hono RPC ([ADR-025](./ADR-025.md), ADR-032).
- **Faster Iteration:** No backward compatibility constraints from serving multiple clients. Frontend and backend evolve together.
- **Better Performance:** Reduced round trips between frontend and backend. Single API call can return complete view data.
- **Simplified Frontend:** Complex business logic lives in the backend where it's easier to test and maintain.
- **Coordinated Deployments:** Frontend and backend changes can be deployed together, simplifying releases.
- **Developer Efficiency:** Developers can work on both frontend and backend in the same monorepo with shared types.

### Negative

- **Tight Coupling:** Backend is tightly coupled to frontend, which is intentional but means:
  - Backend cannot easily serve other clients without creating separate BFF instances
  - Changes to frontend UI may require backend changes
  - Backend is not a general-purpose API
- **Potential Code Duplication:** If multiple Dasolve solutions need similar functionality, code may be duplicated across BFFs (though shared libraries in the monorepo can mitigate this).
- **Learning Curve:** Developers accustomed to generic REST APIs must learn to design use-case-specific endpoints.

### Risks

- **Over-Specialization:** Backend endpoints might become too specific to individual UI components, creating maintenance burden. This will be mitigated by:
  - Designing endpoints at the page/view level, not component level
  - Regular refactoring to consolidate similar endpoints
  - Code reviews to identify over-specialization
- **GraphQL Temptation:** Developers might want GraphQL to avoid creating many endpoints. However:
  - GraphQL adds complexity and shifts data composition to the client
  - Hono with RPC provides sufficient flexibility
  - BFF endpoints can aggregate data just like GraphQL resolvers
  - ADR-031 (Hono) and ADR-032 (Hono RPC) establish the backend stack

## Compliance and Enforcement

### Enforcement

- **Project Structure:** The monorepo structure ([ADR-013](./ADR-013.md)) enforces a single `packages/backend` directory for the BFF.
- **Framework Choice:** Hono (ADR-031) will be the required backend framework, optimized for BFF patterns.
- **Type Safety:** Hono RPC (ADR-032) enforces tight coupling through shared types between frontend and backend.
- **Code Reviews:** Reviewers must ensure:
  - Backend endpoints are designed for specific frontend use cases, not generic CRUD
  - Data aggregation and transformation happen server-side
  - No unnecessary abstraction layers trying to make APIs "reusable"
  - Endpoints return data matching UI needs
- **Architecture Reviews:** Regular reviews to ensure:
  - Backend remains focused on serving the frontend
  - Shared logic is extracted to libraries when appropriate
  - Endpoints are at the right level of granularity

### Standard Implementation

Example BFF endpoint designed for a specific UI view:

```typescript
import { Hono } from "hono";
import { db } from "./db";

const app = new Hono();

// ❌ DON'T: Generic CRUD endpoints
app.get("/api/users/:id", async (c) => {
  const user = await db.users.findById(c.req.param("id"));
  return c.json(user); // Returns raw database entity
});

app.get("/api/orders", async (c) => {
  const orders = await db.orders.findAll();
  return c.json(orders); // Client must filter and transform
});

// ✅ DO: Use-case specific endpoint optimized for dashboard view
app.get("/api/dashboard", async (c) => {
  const userId = c.req.query("userId");

  // Aggregate data from multiple sources
  const [user, recentOrders, stats] = await Promise.all([
    db.users.findById(userId),
    db.orders.findRecent(userId, 5),
    db.analytics.getUserStats(userId),
  ]);

  // Transform into exact shape needed by dashboard UI
  return c.json({
    user: {
      name: user.fullName,
      avatar: user.profilePicture,
      memberSince: user.createdAt,
    },
    orders: recentOrders.map((order) => ({
      id: order.id,
      date: order.createdAt,
      total: order.totalAmount,
      status: order.status,
      itemCount: order.items.length,
    })),
    statistics: {
      totalSpent: stats.lifetimeValue,
      orderCount: stats.totalOrders,
      averageOrderValue: stats.averageOrderValue,
    },
  });
});
```

Example of aggregating external API data:

```typescript
// ✅ DO: Backend aggregates multiple external APIs
app.get("/api/product/:id/details", async (c) => {
  const productId = c.req.param("id");

  // Fetch from multiple sources in parallel
  const [product, reviews, inventory, recommendations] = await Promise.all([
    db.products.findById(productId),
    externalReviewsAPI.getReviews(productId),
    inventoryService.checkStock(productId),
    recommendationEngine.getSimilarProducts(productId),
  ]);

  // Return composed, transformed data
  return c.json({
    product: {
      id: product.id,
      name: product.name,
      description: product.description,
      price: product.price,
      currency: "USD",
    },
    reviews: {
      averageRating: reviews.avgRating,
      totalReviews: reviews.count,
      recent: reviews.items.slice(0, 3).map((r) => ({
        author: r.userName,
        rating: r.stars,
        comment: r.text,
        date: r.createdAt,
      })),
    },
    availability: {
      inStock: inventory.quantity > 0,
      quantity: inventory.quantity,
      estimatedDelivery: inventory.nextDeliveryDate,
    },
    recommendations: recommendations.map((p) => ({
      id: p.id,
      name: p.name,
      image: p.thumbnailUrl,
      price: p.price,
    })),
  });
});
```

### Exceptions

- Solutions requiring integration with third-party systems may need separate API gateways or microservices, but the BFF should still be the primary backend serving the frontend.
- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-013: Standardized Folder Structure (Monorepo)](./ADR-013.md)
- [ADR-015: SPA Architecture](./ADR-015.md)
- [ADR-025: End-to-End Type Safety](./ADR-025.md)
- [ADR-026: No Client-Side Data Wrangling](./ADR-026.md)
- ADR-031: Hono Backend Framework (to be written)
- ADR-032: Hono RPC for Type Safety (to be written)
- [Backend for Frontend Pattern - Sam Newman](https://samnewman.io/patterns/architectural/bff/)
- [Pattern: Backends For Frontends](https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html)
