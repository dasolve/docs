# ADR-028: Frontend Folder Structure

## Context

React applications can quickly become difficult to navigate without a standardized folder structure. As applications grow in complexity, developers need:

- **Clear organization** to find files quickly and understand project layout
- **Consistent patterns** across different projects for easier onboarding
- **Logical separation** of different concerns (routes, components, queries, state)
- **Scalability** that works for both small and large applications
- **Maintainability** with related files grouped together

Without a standard structure, teams often end up with:

- **Inconsistent organization** where every developer structures code differently
- **Scattered files** making it hard to locate related components, styles, and tests
- **Unclear boundaries** between routing, pages, and reusable components
- **Poor discoverability** as the application grows
- **Difficult refactoring** when files are not logically organized

For **enterprise applications** that grow over time with multiple developers:

- **Predictable structure** reduces onboarding time for new team members
- **AI/LLM navigation** requires consistent patterns for agents to understand the codebase
- **Component isolation** enables parallel development and easier testing
- **Clear separation** between routes, pages, and components prevents confusion

A standardized folder structure is essential for building maintainable frontend applications that scale with team size and feature complexity.

## Decision

All **frontends built on the Dasolve framework** must follow this standardized folder structure within the `src/` directory:

```
src/
├── App.tsx              # Root application component
├── main.tsx             # Application entry point
├── routeTree.gen.ts     # Auto-generated TanStack Router route tree (DO NOT EDIT)
├── routes/              # TanStack Router route definitions (ADR-018)
│   ├── __root.tsx       # Root layout
│   ├── index.tsx        # Home route (/)
│   └── users/
│       ├── index.tsx    # Users list route (/users)
│       └── $userId.tsx  # User detail route (/users/:userId)
├── pages/               # Page components referenced by routes (ADR-018)
│   ├── HomePage.tsx
│   ├── UsersListPage.tsx
│   └── UserDetailPage.tsx
├── components/          # Reusable components (one folder per component)
│   ├── UserCard/
│   │   ├── UserCard.tsx             # Presentational component
│   │   ├── UserCardConnected.tsx    # Connected component (if needed)
│   │   ├── UserCard.module.css      # Component styles (ADR-021)
│   │   ├── UserCard.stories.tsx     # Storybook stories (ADR-023)
│   │   └── UserCardConnected.stories.tsx  # Connected stories (if needed)
│   └── Sidebar/
│       ├── Sidebar.tsx
│       ├── Sidebar.module.css
│       └── Sidebar.stories.tsx
├── queries/             # TanStack Query hooks (ADR-019)
│   ├── users.ts         # User-related queries and mutations
│   └── products.ts      # Product-related queries and mutations
├── atoms/               # Jotai global state atoms (ADR-020)
│   ├── ui.ts            # UI state atoms
│   └── preferences.ts   # User preferences atoms
├── hooks/               # Custom React hooks
│   ├── useDebounce.ts
│   └── useLocalStorage.ts
├── api/                 # API client setup
│   └── client.ts        # Hono RPC client (ADR-025)
└── utils/               # Utility functions and helpers
    ├── formatters.ts
    └── validators.ts
```

### Directory Purposes

1. **`App.tsx`**: The root application component that sets up providers (QueryClient, Router, etc.)
2. **`main.tsx`**: The entry point that renders `App.tsx` to the DOM
3. **`routeTree.gen.ts`**: Auto-generated file from TanStack Router - **NEVER edit manually**
4. **`routes/`**: Route definitions using TanStack Router's file-based routing ([ADR-018](./ADR-018.md))
5. **`pages/`**: Page components that contain the UI logic for each route ([ADR-018](./ADR-018.md))
6. **`components/`**: Reusable components organized in folders, each containing the component, styles, and stories
7. **`queries/`**: TanStack Query hooks organized by domain ([ADR-019](./ADR-019.md))
8. **`atoms/`**: Jotai atoms for global client state ([ADR-020](./ADR-020.md))
9. **`hooks/`**: Custom React hooks that don't fit in other categories
10. **`api/`**: API client configuration (Hono RPC setup)
11. **`utils/`**: Pure utility functions and helpers

This decision ensures all Dasolve frontends have a predictable, scalable structure that supports the framework's architectural patterns.

## Do's and Don'ts

### Do

- **DO** follow the exact folder structure defined in this ADR.
- **DO** organize components in individual folders (e.g., `components/UserCard/UserCard.tsx`).
- **DO** keep all component-related files together (component, styles, stories) in the same folder.
- **DO** use the `pages/` directory for page components that are referenced by routes.
- **DO** organize queries by domain (e.g., `queries/users.ts`, `queries/products.ts`).
- **DO** colocate TypeScript types with the files that use them.
- **DO** follow the naming conventions: PascalCase for components, camelCase for utilities.

### Don't

- **DON'T** create additional top-level folders in `src/` without team approval.
- **DON'T** place multiple unrelated components in a single folder.
- **DON'T** edit `routeTree.gen.ts` manually - it's auto-generated by TanStack Router.
- **DON'T** mix page components with reusable components in the same directory.
- **DON'T** create deeply nested component hierarchies without good reason.
- **DON'T** use a global `types/` folder - colocate types with their usage.
- **DON'T** create an `assets/` folder in `src/` - static assets belong in the project root `public/` folder.
- **DON'T** bypass the structure with creative folder names that duplicate existing purposes.
- **DON'T** use `index.ts` files for re-exporting modules. This is forbidden as per [ADR-029](./ADR-029.md).

## Consequences

### Positive

- **Predictability:** Developers always know where to find specific types of files.
- **Scalability:** The structure works for both small and large applications.
- **Component Isolation:** Each component folder is self-contained with all related files.
- **Clear Separation:** Routes, pages, and components have distinct responsibilities and locations.
- **Easy Navigation:** Consistent patterns make it easy to locate files and understand relationships.
- **Tooling Support:** Standard structure enables better IDE support and code generation.
- **AI/LLM Friendly:** Predictable patterns help AI agents navigate and modify the codebase.
- **Onboarding:** New developers can quickly understand the project layout.

### Negative

- **Initial Overhead:** Setting up the structure requires creating multiple directories upfront.
- **Folder Depth:** Component organization adds one level of nesting compared to flat structures.
- **Import Paths:** Some imports may be slightly longer (though tree shaking handles this well).

### Risks

- **Structure Violations:** Developers might create files in the wrong locations. This will be mitigated by:
  - Code review enforcement
  - Project scaffolding tools that generate the correct structure
  - Clear documentation and examples
- **Over-nesting:** Developers might create unnecessary subdirectories in `components/`. This will be mitigated by:
  - Guidelines on when to use subdirectories (only for truly complex components)
  - Code review to identify and simplify over-engineered structures

## Compliance and Enforcement

### Enforcement

- **Project Scaffolding:** All Dasolve frontend templates will generate this exact structure.
- **Code Reviews:** Reviewers must ensure:
  - Files are placed in the correct directories
  - Component folders contain all related files (component, styles, stories)
  - No additional top-level folders are created without justification
  - Page components are in `pages/`, not mixed with reusable components
- **Documentation:** This ADR serves as the definitive reference for folder structure.
- **Examples:** All example projects and tutorials will demonstrate this structure.

### Component Organization Rules

**Simple Components** (single file + styles):

```
components/
└── Button/
    ├── Button.tsx
    ├── Button.module.css
    └── Button.stories.tsx
```

**Components with Connected Variant** ([ADR-024](./ADR-024.md)):

```
components/
└── UserCard/
    ├── UserCard.tsx              # Presentational
    ├── UserCardConnected.tsx     # Connected (stateful)
    ├── UserCard.module.css
    ├── UserCard.stories.tsx
    └── UserCardConnected.stories.tsx
```

**Complex Components** (with subcomponents):

```
components/
└── DataTable/
    ├── DataTable.tsx             # Main component
    ├── DataTableHeader.tsx       # Subcomponent
    ├── DataTableRow.tsx          # Subcomponent
    ├── DataTable.module.css
    └── DataTable.stories.tsx
```

### Import Patterns

**Importing Components:**

```typescript
// From a page component
import { UserCard } from "../components/UserCard/UserCard";
import { Sidebar } from "../components/Sidebar/Sidebar";
```

**Importing Queries:**

```typescript
import { useUser, useUpdateUser } from "../queries/users";
```

**Importing Atoms:**

```typescript
import { sidebarOpenAtom, themeAtom } from "../atoms/ui";
```

**Importing Utilities:**

```typescript
import { formatDate, formatCurrency } from "../utils/formatters";
```

### File Naming Conventions

- **Components:** PascalCase matching the component name (e.g., `UserCard.tsx`)
- **Hooks:** camelCase with `use` prefix (e.g., `useDebounce.ts`)
- **Utilities:** camelCase descriptive names (e.g., `formatters.ts`, `validators.ts`)
- **Queries:** camelCase domain names (e.g., `users.ts`, `products.ts`)
- **Atoms:** camelCase descriptive names (e.g., `ui.ts`, `preferences.ts`)
- **CSS Modules:** Must use `.module.css` extension (e.g., `UserCard.module.css`)
- **Stories:** Match component name with `.stories.tsx` suffix (e.g., `UserCard.stories.tsx`)

### Complete Example

A typical frontend project structure:

```
packages/frontend/
├── public/                  # Static assets (from root, not in src)
│   ├── favicon.ico
│   └── images/
├── src/
│   ├── App.tsx
│   ├── main.tsx
│   ├── routeTree.gen.ts
│   ├── routes/
│   │   ├── __root.tsx
│   │   ├── index.tsx
│   │   ├── about.tsx
│   │   └── users/
│   │       ├── index.tsx
│   │       └── $userId.tsx
│   ├── pages/
│   │   ├── HomePage.tsx
│   │   ├── AboutPage.tsx
│   │   ├── UsersListPage.tsx
│   │   └── UserDetailPage.tsx
│   ├── components/
│   │   ├── Layout/
│   │   │   ├── Layout.tsx
│   │   │   ├── Layout.module.css
│   │   │   └── Layout.stories.tsx
│   │   ├── UserCard/
│   │   │   ├── UserCard.tsx
│   │   │   ├── UserCardConnected.tsx
│   │   │   ├── UserCard.module.css
│   │   │   └── UserCard.stories.tsx
│   │   └── Sidebar/
│   │       ├── Sidebar.tsx
│   │       ├── Sidebar.module.css
│   │       └── Sidebar.stories.tsx
│   ├── queries/
│   │   ├── users.ts
│   │   └── products.ts
│   ├── atoms/
│   │   ├── ui.ts
│   │   └── preferences.ts
│   ├── hooks/
│   │   ├── useDebounce.ts
│   │   └── useMediaQuery.ts
│   ├── api/
│   │   └── client.ts
│   └── utils/
│       ├── formatters.ts
│       └── validators.ts
├── .storybook/             # Storybook configuration
├── vite.config.ts
├── package.json
└── moon.yml
```

### Exceptions

- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-013: Standardized Folder Structure](./ADR-013.md) (Monorepo-level structure)
- [ADR-016: React.JS Framework](./ADR-016.md)
- [ADR-018: TanStack Router](./ADR-018.md)
- [ADR-019: TanStack Query](./ADR-019.md)
- [ADR-020: Jotai State Management](./ADR-020.md)
- [ADR-021: CSS Modules](./ADR-021.md)
- [ADR-023: Storybook](./ADR-023.md)
- [ADR-024: Separation of Stateful and Stateless Components](./ADR-024.md)
- [ADR-025: End-to-End Type Safety](./ADR-025.md)
