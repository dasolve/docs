# ADR-015: React.JS as the Frontend Framework

## Context

Building modern, interactive user interfaces requires a robust frontend framework that can handle complex state management, component composition, and efficient DOM updates. Without a standardized framework, frontend projects would fragment across different technologies (Vue, Angular, Svelte, etc.), leading to:

- Inability to share components and patterns across projects
- Duplicated effort in solving common UI problems
- Difficulty moving developers between projects
- Fragmented tooling and build configurations
- Inconsistent developer experience

The Dasolve framework targets **enterprise data-driven applications** with specific requirements:

- **Complex Data Visualization:** Applications need to render and update large datasets efficiently
- **Long-Running Sessions:** Components must maintain state reliably over extended periods (hours or days)
- **Rich Interactivity:** Support for complex user interactions, forms, and workflows
- **Large Developer Ecosystem:** Access to a mature ecosystem of libraries, tools, and community support
- **Type Safety:** Seamless integration with TypeScript (ADR-001) for end-to-end type safety
- **Component Reusability:** Ability to build and share reusable UI components across projects

A clear decision on the frontend framework is essential to establish consistency, enable code sharing, and provide a solid foundation for building enterprise applications.

## Decision

All **frontends built on the Dasolve framework** must use **React.JS** (version 18 or later) as the UI framework.

React will be used with:

- **TypeScript** (ADR-001) for all component code
- **Function components** and **React Hooks** as the primary programming model
- **Class components are prohibited** for new code
- **Strict Mode** enabled in development to identify potential problems

This decision ensures all Dasolve frontends benefit from React's mature ecosystem, excellent TypeScript support, and proven track record in enterprise applications.

## Do's and Don'ts

### Do

- **DO** use React function components with hooks for all new components.
- **DO** write all React code in TypeScript (`.tsx` files), never plain JavaScript.
- **DO** use React's built-in hooks (`useState`, `useEffect`, `useContext`, `useCallback`, `useMemo`, etc.) appropriately.
- **DO** create custom hooks to encapsulate and share component logic across the application.
- **DO** use `React.StrictMode` in development to identify unsafe lifecycle patterns and deprecated APIs.
- **DO** implement proper cleanup in `useEffect` hooks to prevent memory leaks in long-running sessions.
- **DO** use React's profiler and DevTools to identify performance bottlenecks.
- **DO** leverage React's error boundaries to handle errors gracefully.

### Don't

- **DON'T** create new class components. The class component API is deprecated in favor of function components and hooks.
- **DON'T** use other UI frameworks (Vue, Angular, Svelte) for Dasolve frontend projects.
- **DON'T** use deprecated lifecycle methods or patterns from older React versions.
- **DON'T** mutate state directly. Always use the setter functions from `useState` or state management libraries.
- **DON'T** overuse `useEffect`. Many use cases have better alternatives like derived state or event handlers.
- **DON'T** forget to include all dependencies in `useEffect` dependency arrays (enable ESLint rules to catch this).
- **DON'T** use inline function definitions in JSX props unnecessarily, as this can cause performance issues.

## Consequences

### Positive

- **Mature Ecosystem:** React has the largest ecosystem of UI libraries, component libraries, and tooling.
- **Excellent TypeScript Support:** React's TypeScript definitions are comprehensive and well-maintained, enabling full type safety.
- **Performance:** React's virtual DOM and reconciliation algorithm efficiently update the UI, even with large datasets and complex component trees.
- **Developer Experience:** React DevTools, extensive documentation, and vast community resources make development efficient.
- **Proven Track Record:** React is battle-tested in countless enterprise applications and is maintained by Meta with long-term support.
- **Hooks Model:** React Hooks provide a clean, composable way to manage component logic without the complexity of class components.
- **Community and Hiring:** React's popularity makes it easier to find experienced developers and community support.
- **Integration:** Seamless integration with the Dasolve stack (TanStack Router, TanStack Query, Jotai).

### Negative

- **Learning Curve:** Developers unfamiliar with React and hooks will require training.
- **Opinionated Patterns:** React is relatively unopinionated, requiring additional decisions about state management, routing, etc. (which Dasolve addresses with other ADRs).
- **Bundle Size:** React adds to the bundle size, though this is a one-time cost for long-running enterprise sessions.
- **Dependency on Meta:** React's development is primarily driven by Meta (Facebook), creating some dependency risk (though the open-source nature mitigates this).

### Risks

- **React Version Updates:** Major React updates (e.g., React 19) might introduce breaking changes. This will be mitigated by:
  - Maintaining a conservative update policy
  - Thoroughly testing updates in a staging environment
  - Documenting any required migration steps
- **Improper Hook Usage:** Developers might misuse hooks, causing bugs or performance issues. This will be mitigated by:
  - Enforcing ESLint rules for React hooks
  - Code review requirements
  - Developer training on React best practices

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve frontend scaffolding will include React 19+ with TypeScript configured.
- **Build Configuration:** Vite (ADR-016) will be configured with React plugin and Fast Refresh for optimal development experience.
- **ESLint Rules:** The following ESLint rules will be enforced:
  - `react-hooks/rules-of-hooks` - Enforces proper hooks usage
  - `react-hooks/exhaustive-deps` - Ensures complete dependency arrays
  - `react/jsx-no-bind` - Prevents unnecessary re-renders from inline functions (with appropriate exceptions)
  - Custom rules prohibiting class components in new code
- **Code Reviews:** Reviewers must ensure:
  - All components are function components
  - Proper TypeScript typing for props and state
  - Appropriate hook usage with correct dependency arrays
  - Proper cleanup in effects for long-running sessions
- **Testing:** Components must be testable with React Testing Library (or similar tools that encourage testing best practices).

### Exceptions

- **Legacy Code:** Existing class components in legacy projects may remain, but new features should use function components.
- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-001: Primary Programming Language (TypeScript)](ADR-001.md)
- [ADR-014: SPA Architecture](ADR-014.md)
- [ADR-016: Vite Build Tool](ADR-016.md)
- [ADR-017: TanStack Router](ADR-017.md)
- [ADR-018: TanStack Query](ADR-018.md)
- [ADR-020: Jotai State Management](ADR-020.md)
- [React Official Documentation](https://react.dev/)
- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/)
