# ADR-026: No Path Aliases in TypeScript Code

## Context

TypeScript and modern bundlers support path aliases (also known as path mapping) that allow developers to use clean import paths instead of relative paths:

```typescript
// With path aliases
import { UserCard } from "@/components/UserCard";
import { formatDate } from "@/utils/formatDate";

// Without path aliases (relative imports)
import { UserCard } from "../../components/UserCard";
import { formatDate } from "../../../utils/formatDate";
```

While path aliases appear convenient, they introduce significant problems in **monorepo environments** and **enterprise development**:

### Problems with Path Aliases

1. **Configuration Complexity:**

   - Requires configuration in `tsconfig.json`, bundler config (Vite, Webpack), and test frameworks
   - Different tools may interpret aliases differently, causing inconsistencies
   - Configuration must be kept in sync across all tools

2. **Monorepo Confusion:**

   - In a monorepo with multiple packages, `@/` is ambiguous - which package's root does it refer to?
   - Makes it difficult to move code between packages
   - Breaks when packages import from each other

3. **Refactoring Difficulties:**

   - Moving files breaks imports unless aliases are updated manually
   - IDE refactoring tools may not handle path aliases correctly
   - No clear indication of where files are relative to each other

4. **Onboarding Overhead:**

   - New developers must learn the custom alias configuration
   - Non-standard imports make it harder to understand code structure
   - Different projects may use different alias conventions

5. **Package Imports Already Exist:**
   - For shared code in monorepos, proper package imports (`@org/package-name`) are the correct solution
   - Path aliases try to solve a problem that's better solved by proper package structure

For **Dasolve's monorepo structure** (ADR-013) with multiple packages under `/packages`, path aliases would create ambiguity and maintenance burden. Relative imports and package names provide clarity and work consistently across all tools.

## Decision

**TypeScript code in Dasolve projects must NOT use path aliases for internal paths within a package.** All imports must be either:

1. **Relative imports** for files within the same package:

   ```typescript
   import { UserCard } from "../../components/UserCard";
   import { formatDate } from "../utils/formatDate";
   ```

2. **Package name imports** for code from other packages in the monorepo:

   ```typescript
   import type { AppType } from "@solution/backend";
   import type { User } from "@solution/datamodel-users";
   ```

### What is Prohibited

Path aliases for **internal package paths** (e.g., `"@/*": ["./src/*"]`) are **prohibited**. These create shortcuts within a package and cause the problems described in this ADR.

### What is Allowed

Path mapping for **package names** in the monorepo is **automatically configured by Moonrepo** (ADR-010). The `@solution/*` namespace is used for all packages within the solution (e.g., `@solution/frontend`, `@solution/backend`, `@solution/datamodel-users`).

Moonrepo handles all path configuration automatically - developers should **not** manually configure paths in `tsconfig.json`. The monorepo tooling ensures TypeScript can resolve package imports correctly across the entire solution.

## Do's and Don'ts

### Do

- **DO** use relative imports for files within the same package.
- **DO** use package name imports (`@solution/*`) for cross-package imports in the monorepo.
- **DO** rely on Moonrepo (ADR-010) to handle all path mapping configuration automatically.
- **DO** organize code to minimize deep nesting that would require many `../` levels.
- **DO** rely on IDE features (go-to-definition, auto-import) to handle relative paths.
- **DO** accept that relative imports may look verbose - this verbosity provides clarity about file locations.

### Don't

- **DON'T** configure path aliases for internal package paths in `tsconfig.json` (e.g., `"@/*": ["./src/*"]`).
- **DON'T** use special import prefixes like `@/`, `~/`, `#/` for files within a package.
- **DON'T** configure Vite, Webpack, or other bundlers with internal path resolution aliases.
- **DON'T** try to work around this by creating symlinks or other hacks.
- **DON'T** nest files so deeply that relative imports become unwieldy - this indicates poor file organization.

## Consequences

### Positive

- **No Configuration Overhead:** Zero configuration needed for imports - they just work.
- **Clear File Relationships:** Relative imports show exactly where files are in relation to each other.
- **Tool Compatibility:** Works consistently across TypeScript, bundlers, test frameworks, and IDEs without configuration.
- **Monorepo Clarity:** No ambiguity about which package a path refers to.
- **Easy Refactoring:** Modern IDEs automatically update relative imports when files are moved.
- **Onboarding Simplicity:** Standard JavaScript/TypeScript imports that all developers understand.
- **Package Boundaries:** Clear distinction between intra-package and inter-package imports.

### Negative

- **Verbose Imports:** Relative imports can be longer, especially for deeply nested files.
- **No Shorthand:** Cannot use clean shortcuts like `@/` for common directories.
- **Initial Resistance:** Developers accustomed to path aliases may initially resist the change.

### Risks

- **Deep Nesting Temptation:** Developers might create deeply nested folder structures because they don't have path aliases to hide the complexity. This will be mitigated by:
  - Code review enforcement of flat, logical folder structures
  - Guidelines on proper file organization
  - Refactoring when imports become unwieldy (sign of poor structure)

## Compliance and Enforcement

### Enforcement

- **Bundler Configuration:** Vite, Webpack, or other bundler configs must NOT include path alias resolution.
- **ESLint Rules:** Custom ESLint rules will detect and reject import statements using path aliases.
- **Code Reviews:** Reviewers must ensure:
  - No path alias configuration exists
  - All imports use relative paths or package names
  - File organization is logical and doesn't require excessive nesting
- **Project Templates:** All Dasolve scaffolding will NOT include any path alias configuration.

### Correct Import Patterns

**Within the same package:**

```typescript
// Good: Relative import
import { UserCard } from "../../components/UserCard";
import { useUser } from "../hooks/useUser";

// Bad: Path alias (prohibited)
import { UserCard } from "@/components/UserCard";
import { useUser } from "~/hooks/useUser";
```

**Across packages in monorepo:**

```typescript
// Good: Package name import
import { User } from "@solution/datamodel-users";
import type { AppType } from "@solution/backend";

// Bad: Relative import crossing package boundaries
import { User } from "../../../datamodels/src/User";
```

### File Organization Guidelines

To keep relative imports manageable:

```
src/
├── components/        # Shared components
│   └── UserCard/
│       ├── UserCard.tsx
│       └── UserCard.module.css
├── pages/            # Page components (from ADR-017)
│   ├── HomePage.tsx
│   └── UserDetailPage.tsx
├── hooks/            # Custom hooks
│   └── useUser.ts
├── utils/            # Utility functions
│   └── formatDate.ts
└── api/              # API client
    └── client.ts
```

With this structure, imports rarely exceed `../../`:

```typescript
// From src/pages/UserDetailPage.tsx
import { UserCard } from "../components/UserCard/UserCard";
import { useUser } from "../hooks/useUser";
```

## Exceptions

- Third-party libraries that use path aliases internally are acceptable (we don't control their code).
- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-001: Primary Programming Language (TypeScript)](ADR-001.md)
- [ADR-013: Standardized Folder Structure (Monorepo)](ADR-013.md)
- [ADR-017: TanStack Router](ADR-017.md)
- [TypeScript Module Resolution](https://www.typescriptlang.org/docs/handbook/module-resolution.html)
