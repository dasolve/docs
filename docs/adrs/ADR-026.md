# ADR-026: No Client-Side Data Wrangling

## Context

In traditional frontend development, it's common for applications to fetch raw data from APIs and then transform, filter, aggregate, or combine it on the client side. This pattern creates several problems:

### Performance Issues

- **Browser Resource Constraints:** Client devices (especially mobile) have limited CPU and memory compared to backend servers
- **Battery Drain:** Complex data transformations consume significant battery on mobile devices
- **Network Inefficiency:** Fetching more data than needed wastes bandwidth and slows down the application
- **UI Blocking:** Heavy data processing can freeze the UI, degrading user experience

### Code Complexity

- **Duplicated Logic:** Business logic for data transformation ends up duplicated across frontend and backend
- **Maintenance Burden:** Changes to data structures require updates in multiple places
- **Testing Difficulty:** Complex data transformations in the frontend are harder to test than server-side logic
- **Inconsistency Risk:** Different frontends might transform data differently, leading to inconsistent business logic

### Poor Separation of Concerns

- **Business Logic in UI Layer:** Frontend components should focus on presentation, not business logic
- **Type Safety Challenges:** Client-side transformations bypass the end-to-end type safety provided by Hono RPC (ADR-025)
- **Harder to Reason About:** Mixing data fetching, transformation, and presentation makes code difficult to understand

### Common Anti-Patterns

Examples of problematic client-side data wrangling:

```typescript
// ❌ BAD: Fetching multiple endpoints and combining data
function useUserDashboard(userId: string) {
  const { data: user } = useQuery(["user", userId], () => fetchUser(userId));
  const { data: orders } = useQuery(["orders", userId], () =>
    fetchOrders(userId)
  );
  const { data: payments } = useQuery(["payments", userId], () =>
    fetchPayments(userId)
  );

  // Complex data transformation on the client
  const dashboardData = useMemo(() => {
    if (!user || !orders || !payments) return null;

    return {
      totalSpent: orders.reduce((sum, order) => sum + order.total, 0),
      averageOrderValue: orders.length ? totalSpent / orders.length : 0,
      lastOrder: orders.sort((a, b) => b.date - a.date)[0],
      paymentMethods: [...new Set(payments.map((p) => p.method))],
      // ... more complex transformations
    };
  }, [user, orders, payments]);

  return dashboardData;
}
```

```typescript
// ❌ BAD: Filtering and aggregating data on the client
function useProductAnalytics() {
  const { data: allProducts } = useQuery(["products"], fetchAllProducts);

  // Fetching everything and filtering on client
  const activeProducts = useMemo(
    () => allProducts?.filter((p) => p.status === "active") ?? [],
    [allProducts]
  );

  const categoryStats = useMemo(() => {
    const stats = {};
    activeProducts.forEach((product) => {
      stats[product.category] = (stats[product.category] || 0) + 1;
    });
    return stats;
  }, [activeProducts]);

  return { activeProducts, categoryStats };
}
```

For **enterprise applications** handling large datasets and complex business logic:

- **Scalability:** Backend servers can be scaled horizontally to handle data processing
- **Consistency:** Centralized business logic ensures consistent behavior across all clients
- **Performance:** Dedicated backend resources provide faster data processing
- **Maintainability:** Keeping business logic on the backend simplifies frontend code

Frontends should receive data in the exact shape needed for UI rendering, with all transformations, aggregations, and business logic applied on the backend.

## Decision

All **frontends built on the Dasolve framework** must **NOT** perform data wrangling on the client side.

Instead, frontends must:

- **Fetch data already shaped for UI needs** from backend endpoints designed specifically for each UI component or page
- **Rely on backend APIs** to handle all data transformations, filtering, aggregations, and business logic
- **Use data jobs** (ADR principles 5.8) for complex data processing and preparation
- **Keep queries lean** by only requesting the exact data needed by the UI

### Backend Responsibilities

The backend (following BFF architecture) must provide:

- **View-Specific Endpoints:** Endpoints that return data pre-formatted for specific UI views
- **Aggregated Data:** Pre-calculated totals, averages, counts, and other aggregations
- **Filtered Results:** Server-side filtering based on query parameters
- **Combined Data:** JOIN operations and data from multiple sources combined on the backend
- **Sorted Results:** Server-side sorting based on client preferences

### Frontend Responsibilities

The frontend should:

- **Display data as received** from backend APIs
- **Handle UI state only** (e.g., which tab is active, modal open/closed)
- **Apply minimal formatting** (e.g., date display format, number formatting for display)
- **Use TanStack Query** (ADR-019) to fetch and cache backend data
- **Trust backend data** is in the correct shape and format

This decision ensures frontends remain fast, simple, and focused on presentation while backends handle all business logic and data processing.

## Do's and Don'ts

### Do

- **DO** design backend endpoints that return data in the exact shape needed by the UI.
- **DO** request pre-aggregated data (totals, counts, averages) from the backend.
- **DO** use query parameters to request filtered or sorted data from the backend.
- **DO** create dedicated backend endpoints for complex views that need combined data from multiple sources.
- **DO** use data jobs for heavy data processing and preparation.
- **DO** apply simple display formatting (date formats, number formats) on the client.
- **DO** trust that backend data is already validated and transformed correctly.

### Don't

- **DON'T** fetch data from multiple endpoints and combine them on the client.
- **DON'T** filter, sort, or aggregate data on the client that could be done on the backend.
- **DON'T** perform calculations or business logic on raw data in the frontend.
- **DON'T** use `useMemo` or `useCallback` for complex data transformations. These are optimization tools, not data processing tools.
- **DON'T** fetch all records and filter on the client. Use backend filtering with query parameters.
- **DON'T** implement business rules or validation logic in the frontend (except for basic form validation).
- **DON'T** transform data structures received from the backend. If the shape is wrong, fix the backend endpoint.

## Consequences

### Positive

- **Better Performance:** Backend servers handle data processing, freeing up client resources for UI rendering.
- **Improved UX:** Faster data processing means quicker UI updates and better perceived performance.
- **Simpler Frontend Code:** Components become pure presentation logic, easier to understand and maintain.
- **Consistent Business Logic:** Single source of truth for business rules on the backend.
- **Better Type Safety:** Data arrives in the exact typed shape expected by the UI (via Hono RPC, ADR-025).
- **Easier Testing:** Simple data display is easier to test than complex transformations.
- **Scalability:** Backend data processing can scale independently of frontend.
- **Mobile-Friendly:** Less client-side processing means better battery life and performance on mobile devices.

### Negative

- **More Backend Endpoints:** May require creating specific endpoints for different UI views.
- **Backend Complexity:** Backend needs to understand UI requirements and provide appropriate data shapes.
- **Coordination Required:** Frontend and backend teams must collaborate on API design.
- **Potential Duplication:** Different views might need slightly different endpoints with similar data.

### Risks

- **Over-fetching:** Poorly designed backend endpoints might return more data than needed. This will be mitigated by:
  - Designing endpoints specifically for each UI view's exact needs
  - Using GraphQL-like patterns in Hono if needed for flexible data fetching
  - Regular API performance reviews and optimization
- **Backend Bottlenecks:** Backend might become overloaded with data processing. This will be mitigated by:
  - Using data jobs for heavy processing (ADR principles 5.8)
  - Caching frequently requested aggregations
  - Horizontal scaling of backend services
  - Database indexing and query optimization

## Compliance and Enforcement

### Enforcement

- **Code Reviews:** Reviewers must ensure:
  - Frontend components receive data in the shape they need
  - No complex data transformations in `useMemo`, `useCallback`, or component logic
  - No fetching from multiple endpoints to combine data
  - Backend endpoints are used for filtering, sorting, and aggregation
- **Architecture Reviews:** New features should be reviewed for proper separation:
  - Backend provides view-specific endpoints
  - Complex data processing happens in data jobs
  - Frontend focuses on presentation only
- **Performance Monitoring:** Track client-side JavaScript execution time to identify heavy data processing that should move to the backend.

### Standard Pattern Examples

**✅ CORRECT: Backend provides shaped data**

Backend endpoint (`packages/backend/src/routes/dashboard.ts`):

```typescript
import { Hono } from "hono";
import { db } from "../db";

const app = new Hono();

app.get("/dashboard/:userId", async (c) => {
  const userId = c.req.param("userId");

  // All data wrangling happens on the backend
  const [user, orderStats, recentOrders] = await Promise.all([
    db.users.findById(userId),
    db.orders.aggregate({
      userId,
      stats: ["total_spent", "average_order_value", "order_count"],
    }),
    db.orders.findRecent({ userId, limit: 5 }),
  ]);

  // Return data in the exact shape the UI needs
  return c.json({
    user: {
      id: user.id,
      name: user.name,
      email: user.email,
      memberSince: user.createdAt,
    },
    stats: {
      totalSpent: orderStats.total_spent,
      averageOrderValue: orderStats.average_order_value,
      orderCount: orderStats.order_count,
    },
    recentOrders: recentOrders.map((order) => ({
      id: order.id,
      date: order.createdAt,
      total: order.total,
      status: order.status,
    })),
  });
});

export default app;
```

Frontend component (`packages/frontend/src/pages/DashboardPage.tsx`):

```typescript
import { getRouteApi } from "@tanstack/react-router";
import { useQuery } from "@tanstack/react-query";
import { apiClient } from "@/api/client";

const route = getRouteApi("/dashboard/$userId");

export function DashboardPage() {
  const { userId } = route.useParams();

  // Simple data fetching - no transformation needed
  const { data, isLoading } = useQuery({
    queryKey: ["dashboard", userId],
    queryFn: async () => {
      const response = await apiClient.dashboard[":userId"].$get({
        param: { userId },
      });
      return response.json();
    },
  });

  if (isLoading) return <div>Loading...</div>;
  if (!data) return <div>No data</div>;

  // Pure presentation - just display the data as received
  return (
    <div>
      <h1>Welcome, {data.user.name}</h1>
      <div>
        <h2>Your Statistics</h2>
        <p>Total Spent: ${data.stats.totalSpent}</p>
        <p>Average Order: ${data.stats.averageOrderValue}</p>
        <p>Orders: {data.stats.orderCount}</p>
      </div>
      <div>
        <h2>Recent Orders</h2>
        {data.recentOrders.map((order) => (
          <div key={order.id}>
            {order.date} - ${order.total} - {order.status}
          </div>
        ))}
      </div>
    </div>
  );
}
```

**✅ CORRECT: Backend handles filtering and sorting**

Backend endpoint with query parameters:

```typescript
app.get("/products", async (c) => {
  const category = c.req.query("category");
  const status = c.req.query("status") || "active";
  const sortBy = c.req.query("sortBy") || "name";
  const sortOrder = c.req.query("sortOrder") || "asc";

  // All filtering, sorting on the backend
  const products = await db.products.findMany({
    where: {
      category,
      status,
    },
    orderBy: {
      [sortBy]: sortOrder,
    },
  });

  return c.json({ products });
});
```

Frontend usage:

```typescript
function useProducts(filters: { category?: string; status?: string }) {
  return useQuery({
    queryKey: ["products", filters],
    queryFn: async () => {
      const response = await apiClient.products.$get({
        query: {
          category: filters.category,
          status: filters.status,
        },
      });
      return response.json();
    },
  });
}

function ProductList() {
  const [category, setCategory] = useState<string>();
  const { data } = useProducts({ category, status: "active" });

  // No filtering or sorting here - just display
  return (
    <div>
      <select onChange={(e) => setCategory(e.target.value)}>
        <option value="">All Categories</option>
        <option value="electronics">Electronics</option>
        <option value="clothing">Clothing</option>
      </select>
      {data?.products.map((product) => (
        <div key={product.id}>{product.name}</div>
      ))}
    </div>
  );
}
```

### Acceptable Client-Side Operations

Some lightweight operations are acceptable on the client:

```typescript
// ✅ OK: Simple display formatting
const formattedDate = new Date(user.createdAt).toLocaleDateString();
const formattedPrice = `$${product.price.toFixed(2)}`;

// ✅ OK: UI state management
const [isExpanded, setIsExpanded] = useState(false);
const [selectedTab, setSelectedTab] = useState("profile");

// ✅ OK: Deriving simple UI state
const hasData = data && data.length > 0;
const isEmpty = !data || data.length === 0;
const displayName = user.name || user.email || "Unknown User";
```

**Best Practice:** For simple transformations like formatting, use TanStack Query's `select` option to keep component logic clean:

```typescript
// ✅ BEST: Apply formatting in the query's select option
function useFormattedUser(userId: string) {
  return useQuery({
    queryKey: ["user", userId],
    queryFn: async () => {
      const response = await apiClient.users[":id"].$get({
        param: { id: userId },
      });
      return response.json();
    },
    select: (data) => ({
      ...data,
      // Simple formatting transformations
      formattedJoinDate: new Date(data.createdAt).toLocaleDateString(),
      displayName: data.name || data.email || "Unknown User",
    }),
  });
}

function UserProfile() {
  const { data: user } = useFormattedUser("123");

  // Component receives already-formatted data
  return (
    <div>
      <h1>{user?.displayName}</h1>
      <p>Member since: {user?.formattedJoinDate}</p>
    </div>
  );
}
```

This approach:

- Keeps component logic focused on presentation
- Ensures formatting happens once when data is received
- Makes components easier to test (just check that they display props correctly)
- Leverages TanStack Query's memoization for the selected data

### Exceptions

- Simple display transformations (date formatting, currency formatting) are acceptable.
- UI-only state (expanded/collapsed, selected tab) is frontend responsibility.
- Exceptions to this ADR must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-019: TanStack Query](ADR-019.md)
- [ADR-025: End-to-End Type Safety](ADR-025.md)
- [Principles Section 5.8: Data Jobs](../principles.md#5-data)
- [Backend for Frontend (BFF) Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/backends-for-frontends)
