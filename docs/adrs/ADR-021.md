# ADR-021: CSS Modules for Additional Styling

## Context

While UI component libraries provide comprehensive theming and component styling, enterprise applications often need **additional custom styling** for:

- **Custom components** not available in the chosen UI library
- **Specific layout patterns** unique to the application
- **Brand-specific styling** beyond theme customization
- **Complex CSS** that's difficult to express with inline styling
- **Animation and transitions** requiring keyframes and complex CSS

Various CSS-in-JS and styling approaches exist:

- **Inline Styles:** Limited (no pseudo-classes, media queries, keyframes)
- **Styled Components / Emotion:** Adds runtime overhead, increases bundle size
- **Tailwind CSS:** Can conflict with component library theming, verbose className strings
- **Plain CSS:** Global scope causes naming conflicts and specificity wars
- **CSS Modules:** Locally scoped, zero runtime overhead, standard CSS syntax

For **enterprise applications** with long-running sessions, styling solutions must:

- Be **performant** with minimal runtime overhead
- Provide **local scope** to prevent style conflicts
- Support **standard CSS** features (pseudo-classes, keyframes, media queries)
- **Coexist well** with component library theming systems
- Enable **type safety** with TypeScript

CSS Modules provide the best balance of performance, features, and developer experience for additional styling needs.

## Decision

All **frontends built on the Dasolve framework** must use **CSS Modules** for any extra styling required beyond the chosen UI component library.

CSS Modules will be used for:

- **Custom component styling** that cannot be achieved with the UI component library
- **Complex layouts** requiring specific CSS patterns
- **Animations and keyframes** that need CSS animations
- **Custom utility styles** not covered by the UI library

CSS Modules will **NOT** replace:

- **Component library theming** for global design tokens (colors, typography, spacing)
- **Inline styling props** for simple, component-level style adjustments
- **UI library components** when they already provide the needed functionality

This decision ensures consistent, performant styling while maintaining clear boundaries between the UI library's theming system and custom CSS.

## Do's and Don'ts

### Do

- **DO** use CSS Modules (`.module.css` files) for additional styling needs.
- **DO** keep CSS Module files colocated with their components.
- **DO** use camelCase for CSS class names to enable clean TypeScript imports.
- **DO** leverage standard CSS features (pseudo-classes, media queries, keyframes, grid, flexbox).
- **DO** use CSS variables from the UI library theme in CSS Modules when appropriate.
- **DO** compose CSS Module classes for reusability.
- **DO** use TypeScript to get autocomplete for CSS Module class names.

### Don't

- **DON'T** use global CSS files. All CSS must be locally scoped via CSS Modules.
- **DON'T** use CSS-in-JS libraries (Styled Components, Emotion standalone) for component styling.
- **DON'T** use Tailwind CSS or other utility-first CSS frameworks. They can conflict with component library theming.
- **DON'T** use CSS Modules when the UI library's built-in styling can accomplish the same result.
- **DON'T** create large, monolithic CSS Module files. Keep them focused and component-specific.
- **DON'T** use `!important` to override UI library styles. Use proper specificity or the library's theming system.
- **DON'T** duplicate theme values (colors, spacing) in CSS Modules. Reference theme values via CSS variables instead.

## Consequences

### Positive

- **Zero Runtime Overhead:** CSS Modules are compiled at build time, resulting in standard CSS with no runtime cost.
- **Local Scope:** Class names are automatically scoped, preventing naming conflicts and specificity issues.
- **Standard CSS:** Full access to all CSS features (pseudo-classes, media queries, keyframes, grid, flexbox).
- **Type Safety:** TypeScript provides autocomplete and type checking for CSS Module class names.
- **Performance:** No runtime style injection or JavaScript execution for styling in production.
- **Developer Experience:** Familiar CSS syntax with no new language to learn.
- **Debugging:** Browser DevTools show standard CSS class names (with hash suffix), making debugging straightforward.
- **Compatibility:** Works seamlessly alongside any UI component library's styling system.

### Negative

- **No Dynamic Theming:** CSS Modules don't have direct access to theme values (though CSS variables can bridge this gap).
- **No JavaScript Logic:** Can't use JavaScript for conditional styles (use inline styling or class composition for this).
- **Build Step Required:** CSS Modules require build-time processing (though Vite handles this automatically).
- **Verbosity:** Requires import statements and className assignments, which can be more verbose than inline styling for simple cases.

### Risks

- **Theme Drift:** Hardcoding colors/spacing in CSS Modules could cause inconsistency with the UI library theme. This will be mitigated by:
  - Using CSS custom properties to access theme values
  - Code review enforcement
  - Linting rules to detect hardcoded values
- **Overuse:** Developers might use CSS Modules when the UI library's built-in styling would suffice. This will be mitigated by:
  - Clear guidelines on when to use CSS Modules vs UI library styling
  - Code review enforcement
  - Examples demonstrating appropriate usage

## Compliance and Enforcement

### Enforcement

- **Vite Configuration:** Vite automatically handles CSS Modules for `.module.css` files with no additional configuration.
- **File Naming Convention:** All CSS Module files must use the `.module.css` extension.
- **File Organization:** CSS Module files should be colocated with their components:
  ```
  src/components/
  ├── UserCard/
  │   ├── UserCard.tsx
  │   └── UserCard.module.css
  ```
- **Code Reviews:** Reviewers must ensure:
  - CSS Modules are used appropriately (not replacing UI library when it suffices)
  - Class names use camelCase convention
  - No hardcoded theme values (colors, spacing) without justification
  - CSS Modules are colocated with components
  - No global CSS files are introduced

### Standard Usage Example

Example CSS Module file (`UserCard.module.css`):

```css
.card {
  position: relative;
  transition: transform 0.2s ease-in-out;
}

.card:hover {
  transform: translateY(-4px);
}

.cardHighlighted {
  border: 2px solid var(--color-primary);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.avatar {
  border-radius: 50%;
  object-fit: cover;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.animated {
  animation: fadeIn 0.3s ease-in;
}

@media (max-width: 600px) {
  .card {
    padding: 12px;
  }
}
```

Example component using CSS Modules:

```typescript
import styles from "./UserCard.module.css";

interface UserCardProps {
  name: string;
  avatarUrl: string;
  highlighted?: boolean;
}

export function UserCard({
  name,
  avatarUrl,
  highlighted = false,
}: UserCardProps) {
  return (
    <div
      className={`${styles.card} ${highlighted ? styles.cardHighlighted : ""} ${
        styles.animated
      }`}
    >
      <img src={avatarUrl} className={styles.avatar} alt={name} />
      <h3>{name}</h3>
    </div>
  );
}
```

### Using Theme Values in CSS Modules

Access theme values via CSS custom properties:

```typescript
// In App.tsx or theme setup
const theme = {
  colors: {
    primary: "#1976d2",
    secondary: "#dc004e",
  },
  spacing: {
    unit: 8,
  },
};

function App() {
  return (
    <div
      style={{
        "--color-primary": theme.colors.primary,
        "--color-secondary": theme.colors.secondary,
        "--spacing-unit": `${theme.spacing.unit}px`,
      }}
    >
      <YourApp />
    </div>
  );
}
```

Then use in CSS Modules:

```css
.button {
  background-color: var(--color-primary);
  padding: calc(var(--spacing-unit) * 2);
}

.buttonSecondary {
  background-color: var(--color-secondary);
}
```

### Exceptions

- For extremely simple style adjustments, inline styling may be preferred over creating a CSS Module file.
- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-016: React.JS Framework](./ADR-016.md)
- [CSS Modules Documentation](https://github.com/css-modules/css-modules)
- [Vite CSS Modules Guide](https://vitejs.dev/guide/features.html#css-modules)
