# ADR-033: CORS Support for Backends

## Context

Modern web applications built with the Single Page Application (SPA) architecture ([ADR-015](./ADR-015.md)) commonly run the frontend and backend on different origins. An origin is defined by the combination of scheme (protocol), domain (hostname), and port. For example:

- Frontend: `http://localhost:5173` (Vite development server)
- Backend: `http://localhost:3000` (Hono backend server)

These are considered **different origins** because they have different ports, even though they share the same hostname.

Browsers implement the **Same-Origin Policy** for security, which blocks JavaScript from making requests to a different origin than the one that served the web page. This prevents malicious websites from reading sensitive data from other sites without permission.

However, legitimate cross-origin communication is essential for modern web applications. **Cross-Origin Resource Sharing (CORS)** is a browser mechanism that allows servers to explicitly permit requests from specific origins by setting appropriate HTTP headers.

For **enterprise applications** built on the Dasolve framework:

- **Development Environment:** Frontend (Vite on port 5173) and backend (Hono on port 3000) run on different ports
- **Production Environment:** Frontend (static SPA) and backend API may be hosted on different domains or subdomains
- **Authentication Integration:** Azure AD tokens must be forwarded from frontend to backend ([ADR-022](./ADR-022.md))
- **Type-Safe API Calls:** Hono RPC calls from frontend require proper CORS configuration ([ADR-032](./ADR-032.md))

Without proper CORS configuration:

- Browser blocks all cross-origin requests, preventing frontend-backend communication
- Authentication tokens cannot be forwarded to the backend
- Development workflow is broken
- Application fails to function entirely

**Security Considerations:**

While CORS is necessary, misconfigured CORS creates security vulnerabilities:

- **Wildcard Origins with Credentials:** Using `Access-Control-Allow-Origin: *` with `Access-Control-Allow-Credentials: true` is forbidden by browsers
- **Overly Permissive Origins:** Allowing all origins (`*`) exposes APIs to malicious websites
- **CORS is Not Security:** CORS headers only control which browsers can access the API—they don't prevent direct API access via curl, Postman, or malicious scripts
- **Credential Leakage:** Improper credential handling can expose authentication tokens

## Decision

All **backends built on the Dasolve framework** must support **Cross-Origin Resource Sharing (CORS)** using **Hono's CORS middleware**.

CORS configuration must:

- **Use Hono's Built-in CORS Middleware:** Leverage `hono/cors` for consistent, well-tested CORS handling
- **Explicitly Whitelist Origins:** Never use wildcard (`*`) in production—specify allowed origins explicitly
- **Support Credentials:** Enable `credentials: true` to allow authentication tokens and cookies
- **Configure for Environment:** Use different configurations for development and production
- **Allow Required Headers:** Include `Authorization`, `Content-Type`, and other necessary headers
- **Allow Required Methods:** Support HTTP methods used by the application (GET, POST, PUT, DELETE, etc.)
- **Handle Preflight Requests:** Properly respond to OPTIONS requests sent by browsers

This ensures:

- Frontend and backend can communicate across different origins
- Authentication tokens can be forwarded securely
- Security is maintained through explicit origin whitelisting
- Development and production environments are properly configured

## Do's and Don'ts

### Do

- **DO** use Hono's built-in CORS middleware for all CORS configuration.
- **DO** explicitly whitelist allowed origins—use environment variables for configuration.
- **DO** enable credentials (`credentials: true`) to support Azure AD token forwarding.
- **DO** use different CORS configurations for development and production environments.
- **DO** include `Authorization` header in `allowedHeaders` for token-based authentication.
- **DO** specify allowed HTTP methods based on your API's needs.
- **DO** test CORS configuration in both development and production environments.
- **DO** validate tokens and implement authorization in the backend—don't rely on CORS for security.
- **DO** document allowed origins in deployment documentation.

### Don't

- **DON'T** use wildcard origin (`origin: "*"`) in production environments.
- **DON'T** use wildcard origin with credentials—browsers will block this configuration.
- **DON'T** allow all origins without explicit business justification and security review.
- **DON'T** forget to configure CORS—this will break frontend-backend communication.
- **DON'T** rely on CORS as a security mechanism—always validate requests and tokens in the backend.
- **DON'T** expose sensitive headers unnecessarily.
- **DON'T** hardcode origins in the code—use environment variables.
- **DON'T** skip preflight handling—browsers send OPTIONS requests that must be handled.

## Consequences

### Positive

- **Cross-Origin Communication:** Frontend and backend can communicate across different origins in development and production.
- **Authentication Support:** Azure AD tokens can be forwarded from frontend to backend ([ADR-022](./ADR-022.md)).
- **Type-Safe API Calls:** Hono RPC calls work seamlessly across origins ([ADR-032](./ADR-032.md)).
- **Flexible Deployment:** Frontend and backend can be hosted on different domains/subdomains.
- **Standardized Configuration:** Hono's CORS middleware provides consistent, tested implementation.
- **Environment-Specific:** Different configurations for development and production.
- **Security:** Explicit origin whitelisting prevents unauthorized access from malicious websites.

### Negative

- **Configuration Complexity:** Developers must understand CORS concepts and configure properly.
- **Environment Management:** Different configurations for development and production require careful management.
- **Deployment Coordination:** Production origins must be known and configured before deployment.

### Risks

- **Misconfigured Origins:** Incorrect origin configuration breaks frontend-backend communication. This will be mitigated by:
  - Clear documentation with examples
  - Environment variable templates
  - Testing CORS in both development and production
  - Error messages that indicate CORS issues
- **Security Vulnerabilities:** Overly permissive CORS exposes APIs. This will be mitigated by:
  - Explicit origin whitelisting required
  - Code reviews to catch wildcard usage
  - Security guidelines emphasizing backend validation
  - No wildcard origins in production
- **Preflight Request Failures:** OPTIONS requests must be handled properly. This will be mitigated by:
  - Hono's CORS middleware handles preflight automatically
  - Testing with browser developer tools
  - Documentation of preflight behavior

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve backend scaffolding will include:
  - Hono CORS middleware pre-configured
  - Environment variable configuration
  - Development and production examples
  - Proper credential handling
- **Environment Configuration:** CORS origins managed via environment variables:
  ```typescript
  const allowedOrigins = Bun.env.ALLOWED_ORIGINS?.split(",") || [];
  ```
- **Code Reviews:** Reviewers must ensure:
  - CORS middleware is applied globally to the application
  - No wildcard origins in production code
  - Credentials are enabled for authentication
  - Origins are configured via environment variables
  - Required headers and methods are included
- **Development Standards:** Default development configuration allows `http://localhost:5173` (Vite default port)
- **Security Reviews:** Security audits must verify:
  - Production origins are explicitly whitelisted
  - No wildcard configurations
  - Backend implements proper token validation
  - CORS is not relied upon as the sole security mechanism

### Standard Implementation

**Basic CORS Setup** (`packages/backend/src/index.ts`):

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";

const app = new Hono();

// CORS configuration
const allowedOrigins = Bun.env.ALLOWED_ORIGINS?.split(",") ?? [
  "http://localhost:5173", // Vite development server
];

// Apply CORS middleware globally
app.use(
  "*",
  cors({
    origin: (origin) => {
      // Allow requests with no origin (e.g., mobile apps, curl)
      if (!origin) return null;

      // Check if origin is in allowed list
      if (allowedOrigins.includes(origin)) {
        return origin;
      }

      // Reject other origins
      return null;
    },
    credentials: true,
    allowHeaders: [
      "Content-Type",
      "Authorization",
      "X-Requested-With",
      "Accept",
    ],
    allowMethods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    exposeHeaders: ["Content-Length", "X-Request-Id"],
    maxAge: 600, // Cache preflight for 10 minutes
  })
);

// Your routes here
app.get("/api/health", (c) => c.json({ status: "ok" }));

export default app;
```

**Environment Variable Configuration** (`.env.development`):

```bash
# Development environment
ALLOWED_ORIGINS=http://localhost:5173,http://localhost:3000
```

**Environment Variable Configuration** (`.env.production`):

```bash
# Production environment - explicit whitelisting
ALLOWED_ORIGINS=https://app.example.com,https://www.example.com
```

**Advanced CORS Configuration** (with multiple environments):

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";

const app = new Hono();

// Get environment
const isDevelopment = Bun.env.MODE === "development";
const isProduction = Bun.env.MODE === "production";

// CORS configuration based on environment
const getCorsConfig = () => {
  // Development: permissive for local development
  if (isDevelopment) {
    return cors({
      origin: (origin) => origin || "*", // Allow all origins in development
      credentials: true,
      allowHeaders: ["Content-Type", "Authorization"],
      allowMethods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    });
  }

  // Production: strict origin whitelisting
  const allowedOrigins = import.meta.env.ALLOWED_ORIGINS?.split(",") || [];

  if (allowedOrigins.length === 0) {
    throw new Error(
      "ALLOWED_ORIGINS environment variable must be set in production"
    );
  }

  return cors({
    origin: (origin) => {
      if (!origin) return null;
      return allowedOrigins.includes(origin) ? origin : null;
    },
    credentials: true,
    allowHeaders: [
      "Content-Type",
      "Authorization",
      "X-Requested-With",
      "Accept",
    ],
    allowMethods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    exposeHeaders: ["Content-Length", "X-Request-Id"],
    maxAge: 600,
  });
};

// Apply CORS globally
app.use("*", getCorsConfig());

// Your routes
export default app;
```

**Testing CORS Configuration:**

```typescript
import { describe, it, expect } from "bun:test";
import app from "./index";

describe("CORS Configuration", () => {
  it("should allow requests from whitelisted origin", async () => {
    const res = await app.request("/api/health", {
      method: "GET",
      headers: {
        Origin: "http://localhost:5173",
      },
    });

    expect(res.status).toBe(200);
    expect(res.headers.get("Access-Control-Allow-Origin")).toBe(
      "http://localhost:5173"
    );
    expect(res.headers.get("Access-Control-Allow-Credentials")).toBe("true");
  });

  it("should reject requests from non-whitelisted origin", async () => {
    const res = await app.request("/api/health", {
      method: "GET",
      headers: {
        Origin: "http://malicious-site.com",
      },
    });

    expect(res.headers.get("Access-Control-Allow-Origin")).toBeNull();
  });

  it("should handle preflight OPTIONS request", async () => {
    const res = await app.request("/api/users", {
      method: "OPTIONS",
      headers: {
        Origin: "http://localhost:5173",
        "Access-Control-Request-Method": "POST",
        "Access-Control-Request-Headers": "Content-Type,Authorization",
      },
    });

    expect(res.status).toBe(204);
    expect(res.headers.get("Access-Control-Allow-Origin")).toBe(
      "http://localhost:5173"
    );
    expect(res.headers.get("Access-Control-Allow-Methods")).toContain("POST");
    expect(res.headers.get("Access-Control-Allow-Headers")).toContain(
      "Authorization"
    );
  });
});
```

**Frontend Integration Example:**

```typescript
import { hc } from "hono/client";
import type { AppType } from "@solution/backend";

// Create typed client with credentials enabled
export const api = hc<AppType>(import.meta.env.VITE_API_URL, {
  // Enable credentials to send cookies and allow Authorization header
  fetch: (input: RequestInfo | URL, init?: RequestInit) => {
    return fetch(input, {
      ...init,
      credentials: "include", // Important: enables CORS with credentials
    });
  },
});
```

**With Azure AD Token:**

```typescript
import { useMsal } from "@azure/msal-react";
import { hc } from "hono/client";
import type { AppType } from "@solution/backend";

export function useAuthenticatedApi() {
  const { instance, accounts } = useMsal();

  const getAccessToken = async () => {
    const request = {
      scopes: ["api://your-api-client-id/.default"],
      account: accounts[0],
    };

    try {
      const response = await instance.acquireTokenSilent(request);
      return response.accessToken;
    } catch (error) {
      const response = await instance.acquireTokenPopup(request);
      return response.accessToken;
    }
  };

  const api = hc<AppType>(import.meta.env.VITE_API_URL, {
    fetch: async (input: RequestInfo | URL, init?: RequestInit) => {
      const token = await getAccessToken();

      return fetch(input, {
        ...init,
        credentials: "include", // Enable CORS with credentials
        headers: {
          ...init?.headers,
          Authorization: `Bearer ${token}`, // Add Azure AD token
        },
      });
    },
  });

  return api;
}
```

**Multiple Subdomain Configuration:**

```typescript
import { cors } from "hono/cors";

// Allow multiple subdomains in production
const allowedOrigins = [
  "https://app.example.com",
  "https://admin.example.com",
  "https://dashboard.example.com",
];

app.use(
  "*",
  cors({
    origin: (origin) => {
      if (!origin) return null;
      return allowedOrigins.includes(origin) ? origin : null;
    },
    credentials: true,
    allowHeaders: ["Content-Type", "Authorization"],
    allowMethods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  })
);
```

**Pattern Matching for Dynamic Subdomains (use with caution):**

```typescript
import { cors } from "hono/cors";

// Only use pattern matching if you have dynamic subdomains
// and understand the security implications
app.use(
  "*",
  cors({
    origin: (origin) => {
      if (!origin) return null;

      // Allow all subdomains of example.com in production
      const allowedDomain = "example.com";
      const regex = new RegExp(
        `^https://([a-z0-9-]+\\.)?${allowedDomain.replace(".", "\\.")}$`
      );

      if (regex.test(origin)) {
        return origin;
      }

      return null;
    },
    credentials: true,
    allowHeaders: ["Content-Type", "Authorization"],
    allowMethods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  })
);
```

### Security Best Practices

**Backend Token Validation (Critical):**

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";
import { jwt } from "hono/jwt";

const app = new Hono();

// 1. Apply CORS
app.use(
  "*",
  cors({
    /* ... */
  })
);

// 2. Validate tokens - CORS alone is NOT security!
app.use(
  "/api/*",
  jwt({
    secret: import.meta.env.JWT_SECRET!,
  })
);

// 3. Routes are now protected by both CORS and JWT validation
app.get("/api/protected", (c) => {
  const payload = c.get("jwtPayload");
  return c.json({ message: "Authenticated", user: payload });
});
```

**CORS Error Handling:**

```typescript
app.onError((err, c) => {
  // Log CORS errors for debugging
  if (err.message.includes("CORS")) {
    console.error("CORS Error:", {
      origin: c.req.header("Origin"),
      method: c.req.method,
      path: c.req.path,
    });
  }

  return c.json({ error: "Internal Server Error" }, 500);
});
```

### Exceptions

- **Public APIs** that need to be accessed from any origin may use less restrictive CORS settings, but this requires security review and documentation.
- **Server-to-Server Communication** doesn't require CORS (CORS is a browser security mechanism).
- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-015: SPA Architecture](./ADR-015.md)
- [ADR-022: Azure AD Authentication Support](./ADR-022.md)
- [ADR-030: Backend for Frontend (BFF) Architecture](./ADR-030.md)
- [ADR-031: Hono as the Backend Framework](./ADR-031.md)
- [ADR-032: Hono RPC and Zod Validation](./ADR-032.md)
- [Hono CORS Middleware Documentation](https://hono.dev/docs/middleware/builtin/cors)
- [MDN CORS Documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
- [CORS Specification](https://fetch.spec.whatwg.org/#http-cors-protocol)
