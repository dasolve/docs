# ADR-020: Jotai for Internal Global State Management

## Context

Modern React applications need to manage different types of state:

1. **Server State:** Data from APIs (users, products, orders, etc.)
2. **UI State:** Component-local state (form inputs, toggles, modals)
3. **Global Client State:** Application-wide state (theme preference, sidebar open/closed, user preferences)

While TanStack Query (ADR-019) handles server state excellently, applications still need a solution for **global client state** that must be shared across components without prop drilling.

Traditional global state solutions have limitations:

- **Context API:** Causes re-renders of all consumers even when unrelated state changes
- **Redux:** Requires significant boilerplate and is overkill for simple global state
- **Zustand/Valtio:** Good alternatives but not as composable or TypeScript-friendly as needed
- **Component State + Props:** Prop drilling becomes unwieldy in deep component trees

For **enterprise applications**, global state management must:

- Be **minimal and performant** to avoid unnecessary re-renders in long-running sessions
- Support **TypeScript** with full type safety
- Have **minimal boilerplate** to keep code maintainable
- Be **composable** to derive state from other state atoms
- **Integrate well** with React's Suspense and Concurrent features

It's critical to emphasize that **global state should only be used for client-side UI state**, not server data. Server state belongs in TanStack Query.

## Decision

All **frontends built on the Dasolve framework** must use **Jotai** (version 2 or later) for internal global state management.

Jotai will be used for:

- **Global UI preferences** (theme, language, sidebar state)
- **Application-wide client state** (selected filters, current view mode)
- **Derived state** computed from other atoms
- **Temporary cross-component state** that doesn't belong in the URL or server

Jotai will **NOT** be used for:

- **Server state** (use TanStack Query per ADR-019)
- **URL state** (use TanStack Router search params per ADR-018)
- **Component-local state** (use `useState`)

This decision ensures consistent, performant state management for global client state while maintaining clear boundaries with other state management solutions.

## Do's and Don'ts

### Do

- **DO** use Jotai atoms for global UI state that needs to be shared across components.
- **DO** keep atoms small and focused on a single piece of state.
- **DO** use derived atoms to compute values from other atoms.
- **DO** leverage TypeScript for type-safe atoms with explicit type definitions.
- **DO** use `atomWithStorage` for persisting state to localStorage when appropriate.
- **DO** organize atoms in dedicated files (e.g., `src/atoms/ui.ts`, `src/atoms/preferences.ts`).
- **DO** use Jotai DevTools in development to debug atom state.
- **DO** document the purpose and usage of each atom clearly.

### Don't

- **DON'T** use Jotai for server state. Use TanStack Query (ADR-019) instead.
- **DON'T** use Jotai for URL-based state. Use TanStack Router search params (ADR-018) instead.
- **DON'T** use Jotai for component-local state that doesn't need to be shared. Use `useState`.
- **DON'T** create massive atoms with unrelated state. Keep atoms focused and granular.
- **DON'T** use Redux, Zustand, Valtio, or other global state libraries. Jotai is the standard.
- **DON'T** mutate atom values directly. Always use the setter functions.
- **DON'T** store sensitive data in atoms without proper security considerations.

## Consequences

### Positive

- **Atomic State Model:** Each piece of state is an independent atom, preventing unnecessary re-renders.
- **Minimal Boilerplate:** Creating and using atoms requires very little code compared to Redux.
- **Excellent TypeScript Support:** Full type inference and type safety for atoms and derived atoms.
- **Composable:** Derived atoms can depend on other atoms, creating a reactive dependency graph.
- **React Concurrent Features:** Built with React Suspense and Concurrent Mode in mind.
- **Performance:** Fine-grained subscriptions mean components only re-render when their specific atoms change.
- **Small Bundle Size:** Lightweight library (~3KB) with minimal overhead.
- **Developer Experience:** Simple API that's easy to learn and use.

### Negative

- **Learning Curve:** Developers must learn atomic state concepts and best practices.
- **Debugging Complexity:** With many small atoms, tracking state flow might be challenging (though DevTools help).
- **Less Mature Ecosystem:** Smaller ecosystem compared to Redux, though growing rapidly.

### Risks

- **Overuse:** Developers might use Jotai for server state or component-local state inappropriately. This will be mitigated by:
  - Clear guidelines on when to use Jotai vs TanStack Query vs useState
  - Code review enforcement
  - Examples demonstrating proper usage patterns
- **Atom Proliferation:** Too many atoms could make the codebase hard to navigate. This will be mitigated by:
  - Organizing atoms in logical files
  - Regular code reviews to identify consolidation opportunities
  - Documentation of atom purposes

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve frontend scaffolding will include Jotai pre-configured with:
  - Core Jotai package installed
  - Example atoms for common use cases (theme, sidebar state)
  - DevTools configured for development
  - Folder structure for organizing atoms
- **Atom Organization:** Atoms will be organized in `src/atoms/` directory:
  ```
  src/atoms/
  ├── ui.ts           # UI state atoms (sidebar, theme, etc.)
  └── preferences.ts  # User preferences
  ```
- **Code Reviews:** Reviewers must ensure:
  - Jotai is used only for global client state
  - Server state uses TanStack Query
  - Atoms are properly typed with TypeScript
  - Atoms are focused and not combining unrelated state
  - No other global state libraries are introduced

### Standard Atom Examples

Example atoms for common use cases:

```typescript
import { atom } from "jotai";
import { atomWithStorage } from "jotai/utils";

// Simple atom for sidebar state
export const sidebarOpenAtom = atom(true);

// Persisted atom for theme preference
export const themeAtom = atomWithStorage<"light" | "dark">("theme", "light");

// Derived atom (computed from other atoms)
export const isDarkModeAtom = atom((get) => get(themeAtom) === "dark");

// Atom with read/write logic
export const countAtom = atom(
  (get) => get(baseCountAtom),
  (get, set, update: number) => {
    set(baseCountAtom, get(baseCountAtom) + update);
  }
);
```

Example component using atoms:

```typescript
import { useAtom, useAtomValue, useSetAtom } from "jotai";
import { sidebarOpenAtom, themeAtom } from "./atoms/ui";

function Sidebar() {
  const [sidebarOpen, setSidebarOpen] = useAtom(sidebarOpenAtom);

  return (
    <aside>
      {sidebarOpen && <nav>Navigation items</nav>}
      <button onClick={() => setSidebarOpen(!sidebarOpen)}>
        {sidebarOpen ? "Close" : "Open"}
      </button>
    </aside>
  );
}

// Component that only reads the value (won't cause re-render on write)
function ThemeDisplay() {
  const theme = useAtomValue(themeAtom);
  return <div>Current theme: {theme}</div>;
}

// Component that only sets the value (won't re-render when value changes)
function ThemeToggle() {
  const setTheme = useSetAtom(themeAtom);
  return (
    <button
      onClick={() => setTheme((prev) => (prev === "light" ? "dark" : "light"))}
    >
      Toggle Theme
    </button>
  );
}
```

### Exceptions

- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-016: React.JS Framework](ADR-016.md)
- [ADR-018: TanStack Router](ADR-018.md)
- [ADR-019: TanStack Query](ADR-019.md)
- [Jotai Official Documentation](https://jotai.org/)
- [Jotai Core API](https://jotai.org/docs/core/atom)
- [Jotai Utils](https://jotai.org/docs/utilities/storage)
