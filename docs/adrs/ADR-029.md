# ADR-029: No Barrel Files in Frontend

## Context

Barrel files (also known as index files or re-export files) are a common pattern in TypeScript projects where an `index.ts` file re-exports multiple modules from a directory:

```typescript
// components/index.ts (barrel file)
export { Button } from "./Button/Button";
export { Card } from "./Card/Card";
export { Modal } from "./Modal/Modal";
export { Sidebar } from "./Sidebar/Sidebar";
// ... potentially dozens more
```

This pattern allows developers to import multiple components from a single path:

```typescript
// Using barrel file
import { Button, Card, Modal } from "../components";

// vs direct imports
import { Button } from "../components/Button/Button";
import { Card } from "../components/Card/Card";
import { Modal } from "../components/Modal/Modal";
```

While barrel files appear to simplify imports, they introduce significant problems in modern build tooling, especially with **Vite** ([ADR-017](./ADR-017.md)) and **production bundle optimization**:

### Problems with Barrel Files

1. **Tree Shaking Failures:**

   - Modern bundlers struggle to eliminate unused code when barrel files are present
   - The barrel file creates a single entry point that references all exports, making it difficult for bundlers to determine which exports are actually used
   - Even if you only import one component, the bundler may include dependencies of all components in the barrel
   - This directly contradicts the goal of minimal bundle sizes for production deployments

2. **Larger Bundle Sizes:**

   - Unused code gets included in production bundles, increasing download time
   - For enterprise applications with many components, this can add hundreds of kilobytes of unused code
   - Affects initial page load performance and user experience
   - Wastes bandwidth, especially important for users on slower connections

3. **Build Performance Impact:**

   - Vite's dev server must process entire barrel files even when only one export is used
   - Hot Module Replacement (HMR) becomes slower because changes to one component trigger reprocessing of the entire barrel
   - In large projects, this can add noticeable delays to the development feedback loop
   - Monorepo builds are particularly affected as barrel files create additional module graph complexity

4. **Circular Dependency Risks:**

   - Barrel files increase the likelihood of circular dependencies
   - When multiple modules in a directory import from each other and all are re-exported through a barrel, circular references become more common
   - Circular dependencies can cause runtime errors and unpredictable behavior
   - Debugging circular dependency issues is significantly harder with barrel files

5. **Less Explicit Dependencies:**

   - Direct imports make it immediately clear which specific file a component comes from
   - Barrel files hide the actual source location, making it harder to understand the codebase structure
   - IDE "go to definition" features work less effectively with barrel imports
   - Makes refactoring more difficult as true dependencies are obscured

6. **Maintenance Overhead:**
   - Every new component requires updating the barrel file
   - Easy to forget to add exports, leading to import errors
   - Merge conflicts are more common in barrel files as multiple developers add exports simultaneously
   - No actual benefit compared to letting IDEs auto-import from specific files

For **Dasolve's enterprise applications** with long-running browser sessions and performance requirements, unnecessary code in bundles directly impacts user experience. The small convenience of shorter import statements is not worth the significant performance cost.

## Decision

**Frontend code in Dasolve projects must NOT use barrel files (index.ts re-export files).** All imports must specify the exact file path containing the exported module.

### What is Prohibited

```typescript
// ❌ PROHIBITED: Barrel file (index.ts)
export { Button } from "./Button/Button";
export { Card } from "./Card/Card";
export { Modal } from "./Modal/Modal";

// ❌ PROHIBITED: Importing from barrel
import { Button, Card } from "../components";
```

### What is Required

```typescript
// ✅ REQUIRED: Direct import from specific file
import { Button } from "../components/Button/Button";
import { Card } from "../components/Card/Card";
import { Modal } from "../components/Modal/Modal";
```

### Scope

This prohibition applies to:

- Component directories (`src/components/`)
- Utility directories (`src/utils/`)
- Hook directories (`src/hooks/`)
- Any other directories within the frontend package

This prohibition does **NOT** apply to:

- Third-party libraries that use barrel files (we don't control their code)
- Backend packages where tree shaking is less critical

## Do's and Don'ts

### Do

- **DO** import directly from the specific file containing the export.
- **DO** use your IDE's auto-import feature to automatically generate correct import paths.
- **DO** rely on relative imports ([ADR-014](./ADR-014.md)) to reference components.
- **DO** organize files following the standard structure ([ADR-028](./ADR-028.md)) to keep import paths manageable.
- **DO** use multi-line import statements for clarity when importing multiple items from different files.

### Don't

- **DON'T** create `index.ts` files that re-export modules from a directory.
- **DON'T** use barrel files even if they seem to make imports "cleaner" or shorter.
- **DON'T** create intermediate re-export files with other names (e.g., `exports.ts`, `all.ts`) - these are just barrel files with different names.
- **DON'T** bypass this by creating monolithic files with multiple exports just to avoid multiple imports.
- **DON'T** compromise on file organization to work around barrel file restrictions. Proper structure ([ADR-028](./ADR-028.md)) makes direct imports manageable.

## Consequences

### Positive

- **Optimal Bundle Sizes:** Tree shaking works correctly, eliminating all unused code from production bundles.
- **Faster Build Times:** Vite can process only the modules actually imported, not entire directories.
- **Better HMR Performance:** Hot Module Replacement updates are faster and more targeted in development.
- **Explicit Dependencies:** Import statements clearly show which specific file is being imported from.
- **Easier Refactoring:** Moving files or renaming components is simpler when imports are direct.
- **No Circular Dependencies:** Direct imports significantly reduce the risk of circular dependency issues.
- **Better IDE Support:** Go-to-definition, find-references, and refactoring tools work more reliably.
- **No Maintenance Overhead:** No need to maintain barrel files as components are added or removed.

### Negative

- **Longer Import Statements:** Import paths are more verbose, especially for deeply nested structures.
- **More Import Lines:** Multiple components from the same directory require multiple import statements.
- **Initial Adjustment:** Developers accustomed to barrel files may initially resist the change.

### Risks

- **Import Path Verbosity:** Developers might find import statements too long or cluttered. This will be mitigated by:
  - Following the folder structure from [ADR-028](./ADR-028.md) which keeps nesting reasonable
  - Using IDE auto-import features to generate imports automatically
  - Accepting that explicit imports are a feature, not a bug - they show true dependencies
- **Temptation to Create Barrel Files:** Developers might try to "clean up" imports by creating barrel files. This will be mitigated by:
  - ESLint rules that detect and reject barrel file patterns
  - Code review enforcement
  - Clear documentation of this ADR and its rationale

## Compliance and Enforcement

### Enforcement

- **ESLint Rules:** Custom ESLint rules will detect and reject barrel file patterns:
  - Files named `index.ts` that only contain re-exports
  - Imports from directory paths without specific file names
- **Build Verification:** CI/CD pipelines will check for the presence of barrel files and fail the build if found.
- **Code Reviews:** Reviewers must ensure:
  - No `index.ts` re-export files exist
  - All imports specify the complete file path
  - File organization follows [ADR-028](./ADR-028.md) to keep imports manageable
- **Project Templates:** All Dasolve frontend scaffolding will NOT include barrel files and will demonstrate correct import patterns.

### Correct Import Patterns

**Importing Components:**

```typescript
// ✅ Good: Direct import from specific file
import { UserCard } from "../components/UserCard/UserCard";
import { UserCardConnected } from "../components/UserCard/UserCardConnected";
import { Sidebar } from "../components/Sidebar/Sidebar";

// ❌ Bad: Importing from barrel file
import { UserCard, UserCardConnected, Sidebar } from "../components";
```

**Importing Utilities:**

```typescript
// ✅ Good: Direct import from specific utility file
import { formatDate, formatCurrency } from "../utils/formatters";
import { validateEmail } from "../utils/validators";

// ❌ Bad: Importing from barrel file
import { formatDate, formatCurrency, validateEmail } from "../utils";
```

**Importing Hooks:**

```typescript
// ✅ Good: Direct import from specific hook file
import { useDebounce } from "../hooks/useDebounce";
import { useLocalStorage } from "../hooks/useLocalStorage";

// ❌ Bad: Importing from barrel file
import { useDebounce, useLocalStorage } from "../hooks";
```

### File Organization

Following [ADR-028](./ADR-028.md) folder structure minimizes import path length:

```
src/
├── components/
│   ├── UserCard/
│   │   ├── UserCard.tsx        # Import from here
│   │   └── UserCard.module.css
│   └── Sidebar/
│       ├── Sidebar.tsx         # Import from here
│       └── Sidebar.module.css
├── utils/
│   ├── formatters.ts           # Import from here
│   └── validators.ts           # Import from here
└── hooks/
    ├── useDebounce.ts          # Import from here
    └── useLocalStorage.ts      # Import from here
```

With this structure, imports from pages rarely exceed two levels:

```typescript
// From src/pages/UserDetailPage.tsx
import { UserCard } from "../components/UserCard/UserCard";
import { formatDate } from "../utils/formatters";
import { useDebounce } from "../hooks/useDebounce";
```

### IDE Support

Modern IDEs make direct imports effortless:

- **Auto-import:** Type a component name and the IDE automatically adds the correct import
- **Go to definition:** Jump directly to the source file, not a barrel re-export
- **Refactoring:** Rename or move files and all imports update automatically

### Bundle Analysis

To verify tree shaking is working correctly:

```bash
# Build for production
moon run frontend:build

# Analyze bundle (if using vite-plugin-bundle-analyzer)
moon run frontend:analyze
```

Check that:

- Only used components appear in the bundle
- Unused exports from component files are eliminated
- Bundle sizes are minimal without unnecessary code

## Exceptions

- Third-party libraries that use barrel files internally are acceptable (we don't control their code).
- Backend packages may use barrel files if tree shaking is not a concern for that use case.
- Exceptions to this ADR for frontend code are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-014: No Path Aliases in TypeScript Code](./ADR-014.md)
- [ADR-017: Vite as the Frontend Build Tool](./ADR-017.md)
- [ADR-028: Frontend Folder Structure](./ADR-028.md)
- [Vite: Why Vite - Bare Module Resolving](https://vitejs.dev/guide/why.html)
- [Webpack Tree Shaking Documentation](https://webpack.js.org/guides/tree-shaking/)
- [The Cost of Barrel Exports](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js)
