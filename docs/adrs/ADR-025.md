# ADR-025: End-to-End Type Safety with Backend

## Context

TypeScript provides type safety within the frontend codebase, but traditionally there's a gap between frontend and backend:

- **Manual Type Definitions:** Developers manually write TypeScript interfaces matching backend API responses
- **Type Drift:** Backend changes don't automatically update frontend types, causing runtime errors
- **Maintenance Burden:** Keeping frontend and backend types synchronized requires manual effort
- **No Compile-Time Safety:** API calls use `any` or manually defined types that may not match reality
- **Poor Developer Experience:** No autocomplete for API endpoints, parameters, or response shapes

Traditional approaches to this problem:

- **Manual Typing:** Define interfaces manually (error-prone, requires constant updates)
- **Code Generation:** Run tools to generate types from OpenAPI specs (extra build step, can be out of sync)
- **GraphQL:** Provides type safety but requires different backend architecture

For **enterprise applications**, type safety across the stack is critical to:

- **Prevent Runtime Errors:** Catch API contract violations at compile time
- **Improve Developer Experience:** Autocomplete for endpoints, parameters, and responses
- **Enable Safe Refactoring:** Change backend APIs with confidence that all frontend uses are updated
- **Reduce Bugs:** Eliminate entire classes of bugs related to API mismatches

Hono RPC provides a unique solution: **automatic end-to-end type safety** without code generation or manual type definitions.

## Decision

All **frontends built on the Dasolve framework** must support **end-to-end type safety** with the backend using **Hono RPC**.

This will be achieved through:

- **Hono framework** on the backend exposing RPC-style APIs
- **Hono RPC client** on the frontend automatically inferring types from backend
- **No code generation** - types are inferred directly from backend code
- **Full TypeScript safety** for routes, parameters, request bodies, and responses
- **Compile-time checking** of all API calls

### How It Works

1. Backend defines routes in Hono with TypeScript
2. Backend exports the route types
3. Frontend imports backend types and creates typed client
4. Frontend gets full autocomplete and type checking for API calls
5. Any backend changes immediately cause TypeScript errors in frontend

This decision ensures all API communication is type-safe with zero manual maintenance.

## Do's and Don'ts

### Do

- **DO** use the Hono RPC client for all backend API calls.
- **DO** leverage TypeScript autocomplete for routes, parameters, and responses.
- **DO** let TypeScript errors guide you when backend APIs change.
- **DO** integrate TanStack Query with Hono RPC for data fetching.
- **DO** handle response types properly with TypeScript type narrowing.
- **DO** share validation schemas (Zod) between frontend and backend when needed.

### Don't

- **DON'T** use `fetch` or `axios` directly for backend API calls. Use Hono RPC client.
- **DON'T** manually define types for API responses. Let Hono RPC infer them.
- **DON'T** use `any` type to bypass type checking for API calls.
- **DON'T** ignore TypeScript errors when making API calls. They indicate real problems.
- **DON'T** create separate type definition files for API responses.
- **DON'T** use code generation tools for API types. Hono RPC makes them unnecessary.

## Consequences

### Positive

- **Zero Manual Type Maintenance:** Types are automatically synced between frontend and backend.
- **Compile-Time Safety:** All API calls are checked at compile time, catching errors before runtime.
- **Excellent DX:** Full autocomplete for routes, params, request bodies, and responses.
- **Safe Refactoring:** Backend changes immediately show TypeScript errors in frontend.
- **No Code Generation:** No build step required to generate types.
- **Single Source of Truth:** Backend code is the authoritative source for API types.
- **Prevents Runtime Errors:** Entire classes of bugs (wrong endpoints, missing params, incorrect response handling) are eliminated.

### Negative

- **Coupled Deployment:** Frontend and backend types must stay in sync, potentially requiring coordinated deploys for breaking changes.
- **Monorepo Requirement:** Requires a monorepo structure (ADR-013) where frontend can import backend types directly.
- **Learning Curve:** Developers must understand how Hono RPC client works.

### Risks

- **Breaking Changes:** Backend API changes will cause TypeScript errors in frontend. This is intentional and beneficial, but requires coordination. This will be mitigated by:
  - Using versioning for API changes
  - Coordinating deployments for breaking changes
  - Maintaining backward compatibility when possible
  - Clear communication between frontend and backend teams

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve frontend scaffolding will include Hono RPC client pre-configured:
  - Hono client library installed
  - API client setup with type imports from backend
  - Example API calls demonstrating type safety
  - Integration with TanStack Query
- **Monorepo Structure:** Backend and frontend will be in the same monorepo (ADR-013) to enable easy type imports.
- **Code Reviews:** Reviewers must ensure:
  - Hono RPC client is used for all API calls
  - No manual type definitions for API responses
  - No `any` types in API call code
  - Proper TypeScript error handling
- **CI/CD:** TypeScript compilation will fail if frontend uses outdated backend types.

### Standard Implementation

**Backend Setup** (in `packages/backend/src/index.ts`):

```typescript
import { Hono } from "hono";

const app = new Hono();

// Define typed routes
const routes = app
  .get("/users", (c) => {
    return c.json({
      users: [
        { id: "1", name: "John Doe", email: "john@example.com" },
        { id: "2", name: "Jane Smith", email: "jane@example.com" },
      ],
    });
  })
  .get("/users/:id", (c) => {
    const id = c.req.param("id");
    return c.json({
      id,
      name: "John Doe",
      email: "john@example.com",
    });
  })
  .post("/users", async (c) => {
    const body = await c.req.json<{ name: string; email: string }>();
    return c.json({
      id: "3",
      name: body.name,
      email: body.email,
    });
  });

// Export type for frontend
export type AppType = typeof routes;

export default app;
```

**Frontend Setup** (in `packages/frontend/src/api/client.ts`):

```typescript
import { hc } from "hono/client";
import type { AppType } from "@solution/backend";

// Create typed client
export const apiClient = hc<AppType>(import.meta.env.VITE_API_URL);
```

**Using the Typed Client** (in `src/queries/users.ts`):

```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "../api/client";

function useUsers() {
  return useQuery({
    queryKey: ["users"],
    queryFn: async () => {
      const response = await apiClient.users.$get();
      // TypeScript knows the exact response shape!
      return response.json();
    },
  });
}

function useCreateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: { name: string; email: string }) => {
      const response = await apiClient.users.$post({
        json: data, // TypeScript checks this matches backend expectations!
      });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["users"] });
    },
  });
}

function UserList() {
  const { data, isLoading } = useUsers();
  const createUser = useCreateUser();

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      {/* TypeScript knows 'data.users' exists and its shape! */}
      {data?.users.map((user) => (
        <div key={user.id}>
          {user.name} - {user.email}
        </div>
      ))}
      <button
        onClick={() =>
          createUser.mutate({
            name: "New User",
            email: "new@example.com",
          })
        }
      >
        Add User
      </button>
    </div>
  );
}
```

### Exceptions

- Simple static frontends without backend integration don't need Hono RPC setup.
- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-001: Primary Programming Language (TypeScript)](ADR-001.md)
- [ADR-013: Standardized Folder Structure (Monorepo)](ADR-013.md)
- [ADR-019: TanStack Query](ADR-019.md)
- [Hono RPC Documentation](https://hono.dev/guides/rpc)
