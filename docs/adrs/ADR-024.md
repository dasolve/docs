# ADR-024: Separation of Stateful and Stateless Components

## Context

React components can be categorized into two types based on their responsibilities:

1. **Stateful (Connected) Components:**

   - Manage state using hooks (useState, TanStack Query, Jotai)
   - Handle side effects (useEffect, API calls)
   - Connect to external data sources
   - Contain business logic
   - Orchestrate multiple presentational components

2. **Stateless (Presentational) Components:**
   - Receive all data via props
   - Render UI based solely on props
   - No hooks (except perhaps useMemo/useCallback for optimization)
   - Pure, predictable, and easily testable
   - Reusable across different contexts

Mixing these concerns in a single component creates several problems:

- **Hard to Test:** Components with mixed concerns require complex test setups with mocked hooks and state
- **Poor Reusability:** Components tightly coupled to specific data sources can't be reused in different contexts
- **Difficult to Develop in Isolation:** Can't use Storybook effectively with stateful components
- **Unclear Responsibilities:** Hard to understand what a component does when state management and presentation are mixed
- **Breaks Single Responsibility Principle:** Each component should have one clear purpose

For **enterprise applications** with long-running sessions and complex UIs:

- **Testability** is critical for maintaining quality
- **Reusability** reduces duplication and accelerates development
- **Isolation** enables parallel development of UI and business logic
- **Clarity** helps teams understand and maintain code

A clear separation between stateful and stateless components is essential for building maintainable enterprise applications.

## Decision

All **frontends built on the Dasolve framework** must separate stateful (connected) and stateless (presentational) components.

### Naming Convention

- **Connected components** must have **"Connected"** as a **suffix** in the component name (e.g., `UserCardConnected`)
- **Presentational components** must **NOT** have "Connected" in the name (e.g., `UserCard`)

### Rules for Stateless Components

Stateless (presentational) components **MUST NOT** use any of the following hooks:

- `useState`
- `useEffect`
- `useQuery` / `useMutation` (TanStack Query)
- `useAtom` / `useSetAtom` (Jotai)
- `useContext` (except for theme access)
- Any custom hooks that manage state or side effects

Stateless components **MAY** use:

- `useMemo` / `useCallback` for performance optimization
- `useRef` for DOM references (sparingly)
- `useTheme` (or equivalent hook) when the design system provides a theme hook for accessing theme values

### Component Structure

Typical pattern:

```
UserCard.tsx          // Presentational component (pure, testable)
UserCardConnected.tsx // Connected component (fetches data, manages state)
```

This decision ensures clear separation of concerns, enabling better testing, reusability, and maintainability.

## Do's and Don'ts

### Do

- **DO** create separate files for connected and presentational components.
- **DO** name connected components with "Connected" suffix.
- **DO** keep presentational components pure (data only from props).
- **DO** write Storybook stories for both presentational and connected components (using MSW for connected components as per [ADR-023](./ADR-023.md)).
- **DO** unit test presentational components with simple prop-based assertions.
- **DO** use helper functions outside components and unit test them.
- **DO** pass all data and callbacks as props to presentational components.

### Don't

- **DON'T** use hooks in presentational components (except useMemo/useCallback/useTheme).
- **DON'T** fetch data directly in presentational components.
- **DON'T** manage state in presentational components.
- **DON'T** forget the "Connected" suffix for stateful components.
- **DON'T** mix presentation logic and business logic in the same component.

## Consequences

### Positive

- **Testability:** Presentational components are trivial to test with simple prop inputs.
- **Reusability:** Pure components can be reused in different contexts with different data sources.
- **Storybook Development:** Presentational components work perfectly in Storybook for isolated development.
- **Clarity:** Clear naming convention makes component responsibilities obvious.
- **Parallel Development:** UI and business logic can be developed independently.
- **Performance:** Pure components are easier to optimize and memoize.
- **Maintainability:** Separation of concerns makes code easier to understand and modify.

### Negative

- **More Files:** Requires creating separate files for connected and presentational versions.
- **Boilerplate:** Need to pass props explicitly from connected to presentational components.
- **Learning Curve:** Developers must understand and follow the separation pattern.

### Risks

- **Pattern Violations:** Developers might forget to separate components properly. This will be mitigated by:
  - Clear naming convention that's easy to enforce in code review
  - ESLint rules to detect hooks in non-Connected components
  - Examples and templates demonstrating the pattern
  - Code review enforcement
- **Over-separation:** Developers might over-engineer simple components. This will be mitigated by:
  - Guidelines on when separation is necessary (reusable components)
  - Common sense applied during code review

## Compliance and Enforcement

### Enforcement

- **Naming Convention:** All connected components MUST include "Connected" in their name.
- **ESLint Rules:** Custom ESLint rule to detect hooks in components without "Connected" in the name:
  ```javascript
  // Pseudo-rule: If component doesn't have "Connected" in name,
  // disallow useState, useEffect, useQuery, useAtom, etc.
  ```
- **Code Reviews:** Reviewers must ensure:
  - Connected components have "Connected" in the name
  - Presentational components don't use state/effect hooks
  - Presentational components have Storybook stories
  - Proper separation of concerns
- **Project Templates:** Examples demonstrating the pattern will be included in scaffolding.

### Standard Pattern Example

**Presentational Component** (`UserCard.tsx`):

```typescript
import { Card, CardContent, Avatar, Typography, Button } from "@mui/material";

export interface UserCardProps {
  name: string;
  email: string;
  avatarUrl?: string;
  onEdit: () => void;
  onDelete: () => void;
}

/**
 * Pure presentational component for displaying user information.
 * This component has NO hooks and receives all data via props.
 */
export function UserCard({
  name,
  email,
  avatarUrl,
  onEdit,
  onDelete,
}: UserCardProps) {
  return (
    <Card>
      <CardContent>
        <Avatar src={avatarUrl}>{name.charAt(0)}</Avatar>
        <Typography variant="h6">{name}</Typography>
        <Typography variant="body2" color="text.secondary">
          {email}
        </Typography>
        <Button onClick={onEdit}>Edit</Button>
        <Button onClick={onDelete} color="error">
          Delete
        </Button>
      </CardContent>
    </Card>
  );
}
```

**Connected Component** (`UserCardConnected.tsx`):

```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { UserCard } from "./UserCard";
import { apiClient } from "@/api/client";

export interface UserCardConnectedProps {
  userId: string;
}

/**
 * Connected component that fetches user data and handles user actions.
 * This component uses hooks and manages state.
 */
export function UserCardConnected({ userId }: UserCardConnectedProps) {
  const queryClient = useQueryClient();

  // Fetch user data
  const { data: user, isLoading } = useQuery({
    queryKey: ["users", userId],
    queryFn: async () => {
      const response = await apiClient.users[":id"].$get({
        param: { id: userId },
      });
      return response.json();
    },
  });

  // Delete mutation
  const deleteMutation = useMutation({
    mutationFn: async (id: string) => {
      await apiClient.users[":id"].$delete({ param: { id } });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["users"] });
    },
  });

  const handleEdit = () => {
    // Navigate to edit page or open edit modal
    console.log("Edit user", userId);
  };

  const handleDelete = () => {
    deleteMutation.mutate(userId);
  };

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (!user) {
    return <div>User not found</div>;
  }

  // Pass all data and callbacks to presentational component
  return (
    <UserCard
      name={user.name}
      email={user.email}
      avatarUrl={user.avatarUrl}
      onEdit={handleEdit}
      onDelete={handleDelete}
    />
  );
}
```

**Storybook Story** (for presentational component, `UserCard.stories.tsx`):

```typescript
import type { Meta, StoryObj } from "@storybook/react";
import { UserCard } from "./UserCard";

const meta = {
  title: "Components/UserCard",
  component: UserCard,
  parameters: {
    layout: "centered",
  },
} satisfies Meta<typeof UserCard>;

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    name: "John Doe",
    email: "john.doe@example.com",
    onEdit: () => console.log("Edit clicked"),
    onDelete: () => console.log("Delete clicked"),
  },
};
```

### Helper Functions

Helper functions must be extracted from components and unit tested:

```typescript
// helpers/formatUserName.ts
export function formatUserName(firstName: string, lastName: string): string {
  return `${firstName} ${lastName}`;
}

// helpers/formatUserName.test.ts
import { formatUserName } from "./formatUserName";

describe("formatUserName", () => {
  it("formats user name correctly", () => {
    expect(formatUserName("John", "Doe")).toBe("John Doe");
  });
});
```

### Exceptions

- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-016: React.JS Framework](./ADR-016.md)
- [ADR-019: TanStack Query](./ADR-019.md)
- [ADR-020: Jotai State Management](./ADR-020.md)
- [ADR-023: Storybook](./ADR-023.md)
- [Presentational and Container Components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)
