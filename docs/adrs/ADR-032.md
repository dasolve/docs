# ADR-032: Hono RPC and Zod Validation

## Context

End-to-end type safety between frontend and backend is critical for building robust, maintainable applications. Following the adoption of Hono as the backend framework ([ADR-031](./ADR-031.md)), Dasolve backends need to:

- **Ensure Type Safety:** Share types automatically between frontend and backend without code generation ([ADR-025](./ADR-025.md))
- **Validate Input Data:** Verify that request parameters, bodies, and query strings match expected schemas
- **Provide Developer Experience:** Enable autocomplete and IntelliSense for API calls in the frontend
- **Catch Errors Early:** Identify type mismatches and validation errors at compile time and request time
- **Maintain Single Source of Truth:** Keep validation logic and type definitions co-located

Traditional approaches to these challenges:

- **Manual Type Definitions:** Writing TypeScript interfaces separately for frontend and backend leads to type drift and maintenance burden
- **Runtime-Only Validation:** Using libraries like `joi` or `express-validator` provides runtime validation but no compile-time type safety
- **Code Generation:** Tools like OpenAPI generators create types from specs but require extra build steps and can fall out of sync
- **GraphQL:** Provides type safety but requires a different architecture and additional complexity

For **enterprise applications** built on the Dasolve framework:

- **API Contract Enforcement:** Both frontend and backend must agree on data shapes at compile time and runtime
- **Input Validation:** All user input must be validated before processing to prevent security issues and data corruption
- **Type Inference:** Types should flow naturally from validation schemas to minimize duplication
- **Developer Productivity:** Changes to APIs should immediately surface errors in both frontend and backend code
- **Zero Configuration:** Type safety should work without additional build steps or configuration

Hono provides **Hono RPC** for end-to-end type safety and supports validation middleware for runtime checks. When combined with Zod schemas, this creates a powerful system where:

1. Validation schemas define the expected input shape
2. TypeScript types are automatically inferred from schemas
3. Frontend receives full type safety without manual type definitions
4. Runtime validation ensures data integrity

## Decision

All **backends built on the Dasolve framework** must:

1. **Use Hono RPC** to expose type-safe APIs that frontends can consume with full TypeScript support
2. **Use Zod Validator Middleware** for validating request inputs (body, query parameters, path parameters, headers)
3. **Export the application type** so frontends can create typed clients
4. **Co-locate validation schemas** with route handlers for maintainability

This ensures:

- **End-to-end type safety** from database to UI without code generation
- **Runtime validation** of all inputs with detailed error messages
- **Compile-time checking** of API calls in the frontend
- **Single source of truth** for API contracts via Zod schemas

### Implementation Requirements

Backend routes must:

- Define Zod schemas for all inputs (body, query, params)
- Use `@hono/zod-validator` middleware to validate requests
- Export route types for frontend consumption
- Return properly typed responses

Frontend code must:

- Import backend types via Hono RPC
- Use typed clients for all API calls
- Integrate with TanStack Query ([ADR-019](./ADR-019.md)) for data fetching
- Handle typed responses and errors

## Do's and Don'ts

### Do

- **DO** define Zod schemas for all request inputs (body, query, path parameters).
- **DO** use the `zValidator` middleware from `@hono/zod-validator` for validation.
- **DO** export the application type (`typeof app`) from your backend for frontend consumption.
- **DO** co-locate validation schemas with route definitions for better maintainability.
- **DO** use TypeScript type inference from Zod schemas (avoid manually typing validated data).
- **DO** return consistent error responses when validation fails.
- **DO** leverage Zod's transformation capabilities to parse and transform inputs (e.g., converting strings to numbers).
- **DO** use Zod's refinements for custom validation logic beyond basic type checking.
- **DO** share common Zod schemas across multiple routes when they validate similar data.
- **DO** integrate the Hono RPC client with TanStack Query for data fetching in the frontend.

### Don't

- **DON'T** skip input validation. Always validate request data with Zod schemas.
- **DON'T** manually type validated request data. Let Zod schemas infer the types.
- **DON'T** use `any` or `unknown` types to bypass validation.
- **DON'T** create separate TypeScript interfaces for API request/response types. Use Zod schemas as the source of truth.
- **DON'T** validate data in route handlers directly. Use middleware for separation of concerns.
- **DON'T** use different validation libraries (joi, yup, etc.). Stick to Zod for consistency.
- **DON'T** forget to handle validation errors properly. Return meaningful error messages.
- **DON'T** over-validate. Focus on validating external inputs, not internal function parameters.
- **DON'T** duplicate validation logic. Extract common schemas to shared modules.

## Consequences

### Positive

- **Zero Type Drift:** Frontend types are automatically derived from backend, eliminating manual synchronization
- **Compile-Time Safety:** API calls are checked at compile time, catching errors before runtime
- **Runtime Safety:** All inputs are validated before processing, preventing invalid data from entering the system
- **Excellent Developer Experience:** Full autocomplete and IntelliSense for API calls, parameters, and responses
- **Type Inference:** Zod schemas serve as both validation and type definitions, reducing duplication
- **Clear API Contracts:** Schemas document expected input/output shapes
- **Safe Refactoring:** Changes to backend APIs immediately cause TypeScript errors in frontend
- **Better Error Messages:** Zod provides detailed validation errors that can be returned to clients
- **Security:** Input validation prevents injection attacks and data corruption
- **Single Source of Truth:** Zod schemas define both runtime validation and compile-time types

### Negative

- **Learning Curve:** Developers need to learn Zod schema syntax and Hono RPC patterns
- **Schema Complexity:** Complex validation rules can make schemas verbose
- **Monorepo Dependency:** Requires monorepo structure ([ADR-013](./ADR-013.md)) for type imports
- **Runtime Overhead:** Validation adds minimal processing time to each request (typically negligible)

### Risks

- **Breaking Changes:** Backend schema changes cause TypeScript errors in frontend. This is intentional and beneficial. Mitigated by:
  - Using semantic versioning for API changes
  - Maintaining backward compatibility when possible
  - Coordinating deployments for breaking changes
  - Clear communication between teams
- **Validation Performance:** Complex schemas on high-traffic routes could impact performance. Mitigated by:
  - Keeping schemas focused and efficient
  - Profiling performance-critical endpoints
  - Caching schema compilation results
  - Using Zod's lazy evaluation for complex nested schemas

## Compliance and Enforcement

### Enforcement

- **Project Templates:** All Dasolve backend scaffolding will include:
  - `@hono/zod-validator` middleware pre-configured
  - Example routes with Zod validation
  - Type exports for frontend consumption
  - Integration examples with frontend
- **Frontend Templates:** All Dasolve frontend scaffolding will include:
  - Hono RPC client setup
  - Type imports from backend
  - TanStack Query integration examples
- **Code Reviews:** Reviewers must ensure:
  - All routes have input validation with Zod schemas
  - Application type is exported from backend
  - Frontend uses typed Hono client (no raw `fetch`)
  - Validation errors are handled appropriately
  - No manual type definitions for API contracts
- **TypeScript Compilation:** CI/CD pipelines will fail if frontend uses outdated backend types
- **ESLint Rules:** Standard TypeScript linting ([ADR-011](./ADR-011.md)) enforces type safety

### Standard Implementation

**Backend Setup** (`packages/backend/src/index.ts`):

```typescript
import { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import { z } from "zod";

const app = new Hono();

// Define Zod schemas
const userSchema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
  age: z.number().int().positive().optional(),
});

const userIdSchema = z.object({
  id: z.string().uuid(),
});

const querySchema = z.object({
  page: z.string().transform(Number).pipe(z.number().int().positive()),
  limit: z.string().transform(Number).pipe(z.number().int().min(1).max(100)),
});

// Define routes with validation
const routes = app
  // GET with query parameters
  .get("/users", zValidator("query", querySchema), async (c) => {
    const { page, limit } = c.req.valid("query");
    // TypeScript knows page and limit are numbers!

    const users = await db.users.findMany({
      skip: (page - 1) * limit,
      take: limit,
    });

    return c.json({
      users,
      pagination: {
        page,
        limit,
        total: await db.users.count(),
      },
    });
  })
  // GET with path parameters
  .get("/users/:id", zValidator("param", userIdSchema), async (c) => {
    const { id } = c.req.valid("param");
    // TypeScript knows id is a string!

    const user = await db.users.findById(id);

    if (!user) {
      return c.json({ error: "User not found" }, 404);
    }

    return c.json(user);
  })
  // POST with body validation
  .post("/users", zValidator("json", userSchema), async (c) => {
    const body = c.req.valid("json");
    // TypeScript knows the exact shape of body!

    const newUser = await db.users.create({
      ...body,
      id: crypto.randomUUID(),
    });

    return c.json(newUser, 201);
  })
  // PUT with both path params and body
  .put(
    "/users/:id",
    zValidator("param", userIdSchema),
    zValidator("json", userSchema),
    async (c) => {
      const { id } = c.req.valid("param");
      const body = c.req.valid("json");

      const updatedUser = await db.users.update(id, body);

      return c.json(updatedUser);
    }
  )
  // DELETE
  .delete("/users/:id", zValidator("param", userIdSchema), async (c) => {
    const { id } = c.req.valid("param");

    await db.users.delete(id);

    return c.json({ success: true });
  });

// Export type for frontend
export type AppType = typeof routes;

export default app;
```

**Complex Validation Example** (nested objects, arrays, refinements):

```typescript
import { z } from "zod";
import { zValidator } from "@hono/zod-validator";

// Complex nested schema
const addressSchema = z.object({
  street: z.string().min(1),
  city: z.string().min(1),
  state: z.string().length(2),
  zipCode: z.string().regex(/^\d{5}(-\d{4})?$/),
});

const orderItemSchema = z.object({
  productId: z.string().uuid(),
  quantity: z.number().int().positive(),
  price: z.number().positive(),
});

const createOrderSchema = z
  .object({
    customerId: z.string().uuid(),
    items: z.array(orderItemSchema).min(1),
    shippingAddress: addressSchema,
    billingAddress: addressSchema.optional(),
    notes: z.string().max(500).optional(),
  })
  .refine(
    (data) => {
      // Custom validation: total must be positive
      const total = data.items.reduce(
        (sum, item) => sum + item.price * item.quantity,
        0
      );
      return total > 0;
    },
    {
      message: "Order total must be greater than zero",
    }
  );

app.post("/orders", zValidator("json", createOrderSchema), async (c) => {
  const order = c.req.valid("json");

  // Process order with full type safety
  const result = await processOrder(order);

  return c.json(result, 201);
});
```

**Shared Schemas** (reusable validation):

```typescript
// schemas/common.ts
import { z } from "zod";

export const paginationSchema = z.object({
  page: z
    .string()
    .transform(Number)
    .pipe(z.number().int().positive().default(1)),
  limit: z
    .string()
    .transform(Number)
    .pipe(z.number().int().min(1).max(100).default(20)),
});

export const uuidParamSchema = z.object({
  id: z.string().uuid(),
});

export const dateRangeSchema = z
  .object({
    startDate: z.string().datetime(),
    endDate: z.string().datetime(),
  })
  .refine((data) => new Date(data.endDate) > new Date(data.startDate), {
    message: "End date must be after start date",
  });

// Use in routes
import { paginationSchema, uuidParamSchema } from "./schemas/common";

app.get("/products", zValidator("query", paginationSchema), async (c) => {
  const { page, limit } = c.req.valid("query");
  // ...
});

app.get("/products/:id", zValidator("param", uuidParamSchema), async (c) => {
  const { id } = c.req.valid("param");
  // ...
});
```

**Custom Error Handling** for validation:

```typescript
import { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import { z } from "zod";

const app = new Hono();

app.onError((err, c) => {
  // Handle Zod validation errors
  if (err instanceof z.ZodError) {
    return c.json(
      {
        error: "Validation failed",
        details: err.errors.map((e) => ({
          path: e.path.join("."),
          message: e.message,
        })),
      },
      400
    );
  }

  // Other errors
  console.error("Error:", err);
  return c.json(
    {
      error: "Internal server error",
    },
    500
  );
});
```

**Frontend Setup** (`packages/frontend/src/api/client.ts`):

```typescript
import { hc } from "hono/client";
import type { AppType } from "@solution/backend";

// Create typed client
export const api = hc<AppType>(import.meta.env.VITE_API_URL);
```

**Frontend Usage with TanStack Query** (`src/features/users/queries.ts`):

```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { api } from "@/api/client";

// Typed query hook
export function useUsers(page: number = 1, limit: number = 20) {
  return useQuery({
    queryKey: ["users", page, limit],
    queryFn: async () => {
      const response = await api.users.$get({
        query: {
          page: String(page),
          limit: String(limit),
        },
      });

      if (!response.ok) {
        throw new Error("Failed to fetch users");
      }

      // TypeScript knows the exact response shape!
      return response.json();
    },
  });
}

// Typed query for single user
export function useUser(id: string) {
  return useQuery({
    queryKey: ["users", id],
    queryFn: async () => {
      const response = await api.users[":id"].$get({
        param: { id },
      });

      if (!response.ok) {
        throw new Error("Failed to fetch user");
      }

      return response.json();
    },
    enabled: !!id,
  });
}

// Typed mutation hook
export function useCreateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: { name: string; email: string; age?: number }) => {
      const response = await api.users.$post({
        json: data,
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || "Failed to create user");
      }

      return response.json();
    },
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ["users"] });
    },
  });
}

// Typed mutation for updates
export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      id,
      data,
    }: {
      id: string;
      data: { name: string; email: string; age?: number };
    }) => {
      const response = await api.users[":id"].$put({
        param: { id },
        json: data,
      });

      if (!response.ok) {
        throw new Error("Failed to update user");
      }

      return response.json();
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ["users"] });
      queryClient.invalidateQueries({ queryKey: ["users", variables.id] });
    },
  });
}

// Typed mutation for deletion
export function useDeleteUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: string) => {
      const response = await api.users[":id"].$delete({
        param: { id },
      });

      if (!response.ok) {
        throw new Error("Failed to delete user");
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["users"] });
    },
  });
}
```

**Frontend Component Usage** (`src/features/users/UserList.tsx`):

```typescript
import { useUsers, useCreateUser } from "./queries";

export function UserList() {
  const [page, setPage] = useState(1);
  const { data, isLoading, error } = useUsers(page, 20);
  const createUser = useCreateUser();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {/* TypeScript knows exact shape of data! */}
      {data?.users.map((user) => (
        <div key={user.id}>
          {user.name} ({user.email}){user.age && ` - ${user.age} years old`}
        </div>
      ))}

      {/* Pagination */}
      <div>
        <button
          onClick={() => setPage((p) => Math.max(1, p - 1))}
          disabled={page === 1}
        >
          Previous
        </button>
        <span>
          Page {page} of {Math.ceil((data?.pagination.total || 0) / 20)}
        </span>
        <button
          onClick={() => setPage((p) => p + 1)}
          disabled={page >= Math.ceil((data?.pagination.total || 0) / 20)}
        >
          Next
        </button>
      </div>

      {/* Create user form */}
      <form
        onSubmit={(e) => {
          e.preventDefault();
          const formData = new FormData(e.currentTarget);
          createUser.mutate({
            name: formData.get("name") as string,
            email: formData.get("email") as string,
            age: formData.get("age") ? Number(formData.get("age")) : undefined,
          });
        }}
      >
        <input name="name" placeholder="Name" required />
        <input name="email" type="email" placeholder="Email" required />
        <input name="age" type="number" placeholder="Age (optional)" />
        <button type="submit" disabled={createUser.isPending}>
          {createUser.isPending ? "Creating..." : "Create User"}
        </button>
      </form>
    </div>
  );
}
```

### Exceptions

- Simple read-only endpoints without input parameters may skip validation if appropriate (though this is rare).
- Static file serving or health check endpoints typically don't need validation.
- Exceptions to this ADR are rare and must be approved by the project's lead architect or the Dasolve framework core maintainers.
- All approved exceptions must be documented as a separate ADR that outlines the business/technical justification and the scope of the exception.

## References

- [ADR-001: Primary Programming Language (TypeScript)](./ADR-001.md)
- [ADR-013: Standardized Folder Structure (Monorepo)](./ADR-013.md)
- [ADR-019: TanStack Query for Data Fetching](./ADR-019.md)
- [ADR-025: End-to-End Type Safety](./ADR-025.md)
- [ADR-031: Hono as the Backend Framework](./ADR-031.md)
- [Hono RPC Documentation](https://hono.dev/docs/guides/rpc)
- [Hono Zod Validator Middleware](https://github.com/honojs/middleware/tree/main/packages/zod-validator)
- [Zod Documentation](https://zod.dev/)
